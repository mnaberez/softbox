;K.DIASM
;
;This is a disassembly of K.PRG, the SSE SoftBox terminal program that
;runs on Commodore PET/CBM computers.  This disassembly has no changes
;from the original and reassembles to an identical binary.
;
CINV_LO     = $90     ;KERNAL IRQ vector LO
CINV_HI     = $91     ;KERNAL IRQ vector HI
KEYD        = $026F   ;Keyboard Buffer
SCREEN      = $8000   ;Start of screen RAM
PIA1_ROW    = $E810   ;6520 PIA #1 Keyboard Row Select
PIA1_EOI    = $E811   ;6520 PIA #1 Control
PIA1_COL    = $E812   ;6520 PIA #1 Keyboard Columns Read
PIA2_IEEE   = $E820   ;6520 PIA #2 IEEE Input
PIA2_NDAC   = $E821   ;6520 PIA #2 IEEE NDAC control
PIA2_IOUT   = $E822   ;6520 PIA #2 IEEE Output
PIA2_DAV    = $E823   ;6520 PIA #2 IEEE DAV control
VIA_PB      = $E840   ;6522 VIA Port B
VIA_PCR     = $E84C   ;6522 VIA Peripheral Control Register (PCR)
CHROUT      = $FFD2   ;KERNAL Send a char to the current output device
;
BLINK_CNT   = $01     ;Counts down number of IRQs until cursor reverses
SCRLINE_LO  = $02     ;Pointer to start of current line in screen RAM - LO
SCRLINE_HI  = $03     ;Pointer to start of current line in screen RAM - HI
CURSOR_X    = $04     ;Current X position: 0-79
CURSOR_Y    = $05     ;Current Y position: 0-24
CURSOR_OFF  = $06     ;Cursor state: zero = show, nonzero = hide
SCRCODE_TMP = $07     ;Temporary storage for the last screen code
KEYCOUNT    = $08     ;Number of keys in the buffer at KEYD
X_WIDTH     = $09     ;Width of X in characters (40 or 80)
REVERSE     = $0A     ;Reverse video flag (reverse on = 1)
MOVETO_CNT  = $0B     ;Counts down bytes to consume in a move-to (CTRL_1B) seq
CURSOR_TMP  = $0C     ;Pending cursor state used with CURSOR_OFF
TARGET_LO   = $0D     ;Target address for mem xfers, ind jump, & CTRL_11 - LO
TARGET_HI   = $0E     ;Target address for mem xfers, ind jump, & CTRL_11 - HI
INSERT_LO   = $0F     ;Insert line (CTRL_11) destination screen address - LO
INSERT_HI   = $10     ;Insert line (CTRL_11) destination screen address - HI
XFER_LO     = $11     ;Memory transfer byte counter - LO
XFER_HI     = $12     ;Memory transfer byte counter - HI
CHAR_MASK   = $13     ;Masks incoming bytes for 7- or 8-bit character mode
RTC_JIFFIES = $14     ;Software Real Time Clock
RTC_SECS    = $15     ;  The RTC locations can't be changed because they
RTC_MINS    = $16     ;  are accessed directly by the SoftBox CP/M program
RTC_HOURS   = $17     ;  TIME.COM using DO_MEM_READ and DO_MEM_WRITE.
JIFFY2      = $18     ;Jiffy counter (MSB)
JIFFY1      = $19     ;Jiffy counter
JIFFY0      = $1A     ;Jiffy counter (LSB)
;
*=$0400

BAS_HEADER:
;"50 sys(1039)"
;  Note: The line number is used in a clever way.  It is changed by the
;  configuration utility NEWSYS to either 50 or 60.  This tells the program
;  the frequency (in Hertz) at which the CBM system interrupt occurs.
;
$0400:           .BYT 00,0D,04,32,00,9E,28,31
$0408:           .BYT 30,33,39,29,00,00,00
;
$040F: 4C 66 04  JMP INIT

COPYRIGHT:
;"  SOFTBOX LOADER (C) COPYRIGHT 1981 KEITH FREWIN   "
;"----  REVISON :  5 JULY 1981     "
$0412:           .BYT 20,20,53,4F,46,54,42,4F
$041A:           .BYT 58,20,4C,4F,41,44,45,52
$0422:           .BYT 20,28,43,29,20,43,4F,50
$042A:           .BYT 59,52,49,47,48,54,20,31
$0432:           .BYT 39,38,31,20,4B,45,49,54
$043A:           .BYT 48,20,46,52,45,57,49,4E
$0442:           .BYT 20,20,20,2D,2D,2D,2D,20
$044A:           .BYT 20,52,45,56,49,53,4F,4E
$0452:           .BYT 20,3A,20,20,35,20,4A,55
$045A:           .BYT 4C,59,20,31,39,38,31,20
$0462:           .BYT 20,20,20,20

INIT:
$0466: 78        SEI                ;Disable interrupts
$0467: A9 4F     LDA #<IRQ_HANDLER
$0469: 85 90     STA CINV_LO
$046B: A9 06     LDA #>IRQ_HANDLER
$046D: 85 91     STA CINV_HI        ;Install our interrupt handler
$046F: A9 00     LDA #$00
$0471: 85 08     STA KEYCOUNT       ;Reset key counter (no keys hit)
$0473: A9 00     LDA #$00
$0475: 85 14     STA RTC_JIFFIES    ;Reset software real time clock
$0477: 85 15     STA RTC_SECS
$0479: 85 16     STA RTC_MINS
$047B: 85 17     STA RTC_HOURS
$047D: 85 18     STA JIFFY2         ;Reset jiffy counter
$047F: 85 19     STA JIFFY1
$0481: 85 1A     STA JIFFY0
$0483: A9 0A     LDA #$0A
$0485: 8D 3D 0B  STA REPEATCOUNT1   ;Store #$0A in REPEATCOUNT1
$0488: 58        CLI                ;Enable interrupts again
$0489: A9 0E     LDA #$0E
$048B: 8D 4C E8  STA VIA_PCR        ;Graphic mode = lowercase
$048E: 20 84 07  JSR CTRL_02        ;Go to 7-bit character mode
$0491: A9 14     LDA #$14
$0493: 85 01     STA BLINK_CNT      ;Initialize cursor blink countdown
$0495: A9 00     LDA #$00
$0497: 85 06     STA CURSOR_OFF     ;Cursor state = show the cursor
$0499: 85 0B     STA MOVETO_CNT     ;Move-to counter = not in a move-to seq

INIT_4080:
;Detect 40/80 column screen and store in X_WIDTH
;
;This routine checks for an 80 column screen by writing to screen RAM
;that should not be present on a 40 column machine.  If the computer
;has been modified so that it has a 40 column screen but the extra
;screen RAM is present, this routine will think the machine has 80 columns.
;
;X_WIDTH is also used in the keyboard scanning routine to select between
;business keyboard (80 columns) or graphics keyboard (40 columns).  This
;means the 2001B machines (40-column, business keyboard) are not supported.
;
$049B: A9 28     LDA #$28
$049D: 85 09     STA X_WIDTH        ;X_WIDTH = 40 characters
$049F: A9 55     LDA #$55
$04A1: 8D 00 80  STA SCREEN         ;Store #$55 in first byte of screen RAM.
$04A4: 0A        ASL A
$04A5: 8D 00 84  STA SCREEN+$400    ;Store #$AA in first byte of 80 col page.
$04A8: CD 00 84  CMP SCREEN+$400    ;Does it read back correctly?
$04AB: D0 08     BNE INIT_TERM      ;  No: we're done, X_WIDTH = 40.
$04AD: 4A        LSR A
$04AE: CD 00 80  CMP SCREEN         ;Is the #$55 still intact?
$04B1: D0 02     BNE INIT_TERM      ;  No: incomplete decoding, X_WIDTH = 40
$04B3: 06 09     ASL X_WIDTH        ;  Yes: X_WIDTH = 80 characters

INIT_TERM:
$04B5: A9 1A     LDA #$1A           ;Load #$1A = CTRL_1A Clear Screen
$04B7: 20 E8 06  JSR PROCESS_BYTE   ;Call into terminal to execute clear screen
$04BA: 20 D4 08  JSR CTRL_06        ;Clear all tab stops

INIT_IEEE:
;
;6522 VIA            6520 PIA #1            6520 PIA #2
;  PB0: NDAC_IN       PA0-7: Data In         CA1: ATN_IN
;  PB1: NRFD_OUT      PB0-7: Data Out        CA2: NDAC_OUT
;  PB2: ATN_OUT       CA2: EOI_OUT           CB1: SRQ_IN
;  PB6: NFRD_IN                              CB2: DAV_OUT
;  PB7: DAV_IN
;
$04BD: AD 22 E8  LDA PIA2_IOUT      ;Read clears IRQA1 flag (ATN_IN detect)

$04C0: AD 40 E8  LDA VIA_PB
$04C3: 29 FB     AND #%11111011
$04C5: 8D 40 E8  STA VIA_PB         ;ATN_OUT=low

$04C8: A9 34     LDA #%00110100
$04CA: 8D 23 E8  STA PIA2_DAV       ;DAV_OUT=low

$04CD: A9 C6     LDA #$C6
$04CF: 8D 22 E8  STA PIA2_IOUT      ;Put #$39 on IEEE data lines

$04D2: A0 00     LDY #$00
L_04D4:
$04D4: 88        DEY
$04D5: D0 FD     BNE L_04D4         ;Let #$39 sit on the lines so the SoftBox sees it

$04D7: A9 FF     LDA #$FF
$04D9: 8D 22 E8  STA PIA2_IOUT      ;Release IEEE data lines

$04DC: A9 3C     LDA #%00111100
$04DE: 8D 11 E8  STA PIA1_EOI       ;EOI_OUT=high, disable IRQ from CA1 (Cassette Read)
$04E1: 8D 21 E8  STA PIA2_NDAC      ;NDAC_OUT=high, disable IRQ from CA1 (ATN_IN)
$04E4: 8D 23 E8  STA PIA2_DAV       ;DAV_OUT=high, disable IRQ from CB1 (SRQ_IN),
                                    ;  CB1 transition mode = positive (low-to-high)
MAIN_LOOP:
$04E7: A9 3C     LDA #%00111100
$04E9: 8D 21 E8  STA PIA2_NDAC      ;NDAC_OUT=high

$04EC: AD 40 E8  LDA VIA_PB
$04EF: 09 06     ORA #%00000110
$04F1: 8D 40 E8  STA VIA_PB         ;NRFD_OUT=high, ATN_OUT=high

WAIT_FOR_SRQ:
$04F4: AD 23 E8  LDA PIA2_DAV       ;Read PIA #2 CRB
$04F7: 0A        ASL A              ;  bit 7 = IRQB1 flag for CB1 (SRQ_IN detect)
$04F8: 90 FA     BCC WAIT_FOR_SRQ   ;Wait until SRQ_IN is detected

$04FA: AD 22 E8  LDA PIA2_IOUT      ;Read clears IRQB1 flag (SRQ_IN detect)

$04FD: A9 34     LDA #%00110100
$04FF: 8D 21 E8  STA PIA2_NDAC      ;NDAC_OUT=low

$0502: AE 20 E8  LDX PIA2_IEEE      ;Read IEEE data byte with command from SoftBox
                                    ;
                                    ; Bit 7: CBM to SoftBox: Key not available
                                    ; Bit 6: CBM to SoftBox: Key available
                                    ; Bit 5: SoftBox to CBM: Transfer from the SoftBox to CBM memory
                                    ; Bit 4: SoftBox to CBM: Transfer from CBM memory to the SoftBox
                                    ; Bit 3: SoftBox to CBM: Jump to a subroutine in CBM memory
                                    ; Bit 2: SoftBox to CBM: Write to the terminal screen
                                    ; Bit 1: SoftBox to CBM: Wait for a key and send it
                                    ; Bit 0: SoftBox to CBM: Key available?

$0505: 8A        TXA                ;Remember the original command byte in X
$0506: 6A        ROR A
$0507: A9 7F     LDA #$7F           ;Next byte we'll put on IEEE will be #$80 (key available)
$0509: B0 06     BCS SEND_KEY_AVAIL ;Bypass the key buffer check

$050B: A4 08     LDY KEYCOUNT       ;Is there a key in the buffer?
$050D: D0 02     BNE SEND_KEY_AVAIL ;  No:  Response will be #$80 (key available)
$050F: A9 BF     LDA #$BF           ;  Yes: Response will be #$40 (no key available)

SEND_KEY_AVAIL:
$0511: 8D 22 E8  STA PIA2_IOUT      ;Drive only bit 7 (no key) or bit 6 (key) on the bus

HANDSHAKE:
$0514: AD 20 E8  LDA PIA2_IEEE      ;Read IEEE data byte
$0517: 29 3F     AND #%00111111     ;We are driving only bits 7 and 6 with the keyboard status
$0519: C9 3F     CMP #%00111111
$051B: D0 F7     BNE HANDSHAKE      ;Wait for the SoftBox to drive the other lines to zero

$051D: A9 FF     LDA #$FF
$051F: 8D 22 E8  STA PIA2_IOUT      ;Release all data lines

DISPATCH_COMMAND:
$0522: 8A        TXA                ;Recall the original command byte from X
$0523: 6A        ROR A              ;Bit 0: Key availability was already answered above
$0524: 90 C1     BCC MAIN_LOOP      ;       so we're done
$0526: 6A        ROR A
$0527: 90 0C     BCC JMP_DO_GET_KEY ;Bit 1: Wait for a key and send it
$0529: 6A        ROR A
$052A: 90 0C     BCC DO_TERMINAL    ;Bit 2: Write to the terminal screen
$052C: 6A        ROR A
$052D: 90 17     BCC DO_MEM_JSR     ;Bit 3: Jump to a subroutine in CBM memory
$052F: 6A        ROR A
$0530: 90 5D     BCC DO_MEM_READ    ;Bit 4: Transfer from CBM memory to the SoftBox
$0532: 4C 5B 05  JMP DO_MEM_WRITE   ;Bit 5: Transfer from the SoftBox to CBM memory

JMP_DO_GET_KEY:
$0535: 4C C6 05  JMP DO_GET_KEY

DO_TERMINAL:
;Write to the terminal screen
$0538: 20 CF 05  JSR IEEE_GET_BYTE
$053B: A2 3C     LDX #%00111100
$053D: 8E 21 E8  STX PIA2_NDAC      ;NDAC_OUT=high
$0540: 20 E8 06  JSR PROCESS_BYTE
$0543: 4C E7 04  JMP MAIN_LOOP

DO_MEM_JSR:
;Jump to a subroutine in CBM memory
$0546: 20 CF 05  JSR IEEE_GET_BYTE  ;Get byte
$0549: 85 0D     STA TARGET_LO      ; -> Target vector lo
$054B: 20 CF 05  JSR IEEE_GET_BYTE  ;Get byte
$054E: 85 0E     STA TARGET_HI      ; -> Target vector hi
$0550: A2 3C     LDX #%00111100
$0552: 8E 21 E8  STX PIA2_NDAC      ;NDAC_OUT=high
$0555: 20 1B 07  JSR JUMP_CMD       ;Jump to the subroutine through TARGET_LO
$0558: 4C E7 04  JMP MAIN_LOOP

DO_MEM_WRITE:
;Transfer bytes from the SoftBox to CBM memory
$055B: 20 CF 05  JSR IEEE_GET_BYTE
$055E: 85 11     STA XFER_LO
$0560: 20 CF 05  JSR IEEE_GET_BYTE
$0563: 85 12     STA XFER_HI
$0565: 20 CF 05  JSR IEEE_GET_BYTE
$0568: 85 0D     STA TARGET_LO
$056A: 20 CF 05  JSR IEEE_GET_BYTE
$056D: 85 0E     STA TARGET_HI

$056F: A0 00     LDY #$00
L_0571:
$0571: 20 CF 05  JSR IEEE_GET_BYTE
$0574: 91 0D     STA (TARGET_LO),Y
$0576: C8        INY
$0577: D0 02     BNE L_057B

$0579: E6 0E     INC TARGET_HI
L_057B:
$057B: A5 11     LDA XFER_LO
$057D: 38        SEC
$057E: E9 01     SBC #$01
$0580: 85 11     STA XFER_LO
$0582: A5 12     LDA XFER_HI
$0584: E9 00     SBC #$00
$0586: 85 12     STA XFER_HI
$0588: 05 11     ORA XFER_LO
$058A: D0 E5     BNE L_0571
$058C: 4C E7 04  JMP MAIN_LOOP

DO_MEM_READ:
;Transfer bytes from CBM memory to the SoftBox
$058F: 20 CF 05  JSR IEEE_GET_BYTE
$0592: 85 11     STA XFER_LO
$0594: 20 CF 05  JSR IEEE_GET_BYTE
$0597: 85 12     STA XFER_HI
$0599: 20 CF 05  JSR IEEE_GET_BYTE
$059C: 85 0D     STA TARGET_LO
$059E: 20 CF 05  JSR IEEE_GET_BYTE
$05A1: 85 0E     STA TARGET_HI
$05A3: A0 00     LDY #$00
L_05A5:
$05A5: 88        DEY
$05A6: D0 FD     BNE L_05A5   ; delay
L_05A8:
$05A8: B1 0D     LDA (TARGET_LO),Y
$05AA: 20 FB 05  JSR IEEE_SEND_BYTE
$05AD: C8        INY
$05AE: D0 02     BNE L_05B2
$05B0: E6 0E     INC TARGET_HI
L_05B2:
$05B2: A5 11     LDA XFER_LO
$05B4: 38        SEC
$05B5: E9 01     SBC #$01
$05B7: 85 11     STA XFER_LO
$05B9: A5 12     LDA XFER_HI
$05BB: E9 00     SBC #$00
$05BD: 85 12     STA XFER_HI
$05BF: 05 11     ORA XFER_LO
$05C1: D0 E5     BNE L_05A8
$05C3: 4C E7 04  JMP MAIN_LOOP

DO_GET_KEY:
;Wait for a key and send it to the SoftBox.
;
;At the CP/M "A>" prompt, the SoftBox sends this command and then
;waits for the CBM to answer.
;
$05C6: 20 2E 06  JSR GET_KEY         ;Block until we get a key.  Key will be in A.
$05C9: 20 FB 05  JSR IEEE_SEND_BYTE  ;Send the key to the Softbox.
$05CC: 4C E7 04  JMP MAIN_LOOP

IEEE_GET_BYTE:
;Receive a byte from the SoftBox over the IEEE-488 bus.
;
$05CF: AD 40 E8  LDA VIA_PB
$05D2: 09 02     ORA #%00000010
$05D4: 8D 40 E8  STA VIA_PB         ;NRFD_OUT=high

L_05D7:
$05D7: 2C 40 E8  BIT VIA_PB
$05DA: 30 FB     BMI L_05D7         ;Wait until DAV_IN=low

$05DC: AD 20 E8  LDA PIA2_IEEE      ;Read data byte
$05DF: 49 FF     EOR #$FF           ;Invert it
$05E1: 48        PHA                ;Push data byte

$05E2: AD 40 E8  LDA VIA_PB
$05E5: 29 FD     AND #%11111101
$05E7: 8D 40 E8  STA VIA_PB         ;NRFD_OUT=low

$05EA: A9 3C     LDA #%00111100
$05EC: 8D 21 E8  STA PIA2_NDAC      ;NDAC_OUT=high

L_05EF:
$05EF: 2C 40 E8  BIT VIA_PB
$05F2: 10 FB     BPL L_05EF         ;Wait until DAV_IN=high

$05F4: A9 34     LDA #%00110100
$05F6: 8D 21 E8  STA PIA2_NDAC      ;NDAC_OUT=low

$05F9: 68        PLA
$05FA: 60        RTS

IEEE_SEND_BYTE:
;Send a byte to the SoftBox over the IEEE-488 bus.
;
$05FB: 49 FF     EOR #$FF           ;Invert the byte
$05FD: 8D 22 E8  STA PIA2_IOUT      ;Put byte on IEEE data output lines

$0600: AD 40 E8  LDA VIA_PB
$0603: 09 02     ORA #%00000010
$0605: 8D 40 E8  STA VIA_PB         ;NRFD_OUT=high

$0608: A9 3C     LDA #%00111100
$060A: 8D 21 E8  STA PIA2_NDAC      ;NDAC_OUT=high

L_060D:
$060D: 2C 40 E8  BIT VIA_PB
$0610: 50 FB     BVC L_060D         ;Wait until NRFD_IN=high
$0612: A9 34     LDA #%00110100
$0614: 8D 23 E8  STA PIA2_DAV       ;DAV_OUT=low

L_0617:
$0617: AD 40 E8  LDA VIA_PB
$061A: 4A        LSR A
$061B: 90 FA     BCC L_0617         ;Wait until NDAC_IN=high

$061D: A9 3C     LDA #%00111100
$061F: 8D 23 E8  STA PIA2_DAV       ;DAV_OUT=high

$0622: A9 FF     LDA #$FF
$0624: 8D 22 E8  STA PIA2_IOUT      ;Release data lines

L_0627:
$0627: AD 40 E8  LDA VIA_PB
$062A: 4A        LSR A
$062B: B0 FA     BCS L_0627         ;Wait until NDAC_IN=low
$062D: 60        RTS

GET_KEY:
;Get the next key waiting from the keyboard buffer and return
;it in the accumulator.  If there is no key, this routine will
;block until it gets one.  Meanwhile, the interrupt handler
;calls SCAN_KEYB and puts any key into the buffer.
;
$062E: A9 FF     LDA #$FF        ;FF = no key
$0630: 78        SEI             ;Disable interrupts
$0631: A6 08     LDX KEYCOUNT    ;Is there a key waiting in the buffer?
$0633: F0 14     BEQ L_0649      ;  No: nothing to do with the buffer.
$0635: AD 6F 02  LDA KEYD        ;Read the next key in the buffer (FIFO)
$0638: 48        PHA             ;Push the key onto the stack
$0639: A2 00     LDX #$00
$063B: C6 08     DEC KEYCOUNT    ;Keycount = Keycount - 1
L_063D:
$063D: BD 70 02  LDA KEYD+1,X    ;Remove the key from the buffer by rotating
$0640: 9D 6F 02  STA KEYD,X      ;  bytes in the buffer to the left
$0643: E8        INX
$0644: E4 08     CPX KEYCOUNT    ;Finished updating the buffer?
$0646: D0 F5     BNE L_063D      ;  No: loop until we're done.
$0648: 68        PLA             ;Pull the key off the stack.
L_0649:
$0649: 58        CLI             ;Enable interrupts again
$064A: C9 FF     CMP #$FF        ;No key or key is "NONE" in the tables?
$064C: F0 E0     BEQ GET_KEY     ;  No key:  loop until we get one.
$064E: 60        RTS             ;  Got key: done.  Key is now in A.

IRQ_HANDLER:
;On PET/CBM, an IRQ occurs at 50 or 60 Hz depending on the model and ROMs.
;The 6502 calls the main IRQ entry point ($E442 on BASIC 4.0) which pushes
;A, X, and Y onto the stack and then executes JMP (cinv_lo).  We install
;this routine, IRQ_HANDLER, into cinv_lo during init.
;
$064F: E6 1A     INC JIFFY0          ;Counts number of Interrupts
$0651: D0 06     BNE IRQ_CLOCK
$0653: E6 19     INC JIFFY1          ;counter
$0655: D0 02     BNE IRQ_CLOCK
$0657: E6 18     INC JIFFY2          ;counter

IRQ_CLOCK:
;Update the jiffy clock
$0659: E6 14     INC RTC_JIFFIES     ;Increment Jiffies
$065B: A5 14     LDA RTC_JIFFIES
$065D: CD 03 04  CMP BAS_HEADER+3    ;50 or 60 (Hz).  See note in BAS_HEADER.
$0660: D0 28     BNE IRQ_BLINK
$0662: A9 00     LDA #$00            ;Reset RTC_JIFFIES counter
$0664: 85 14     STA RTC_JIFFIES
$0666: E6 15     INC RTC_SECS        ;Increment Seconds
$0668: A5 15     LDA RTC_SECS
$066A: C9 3C     CMP #$3C            ;Have we reached 60 seconds?
$066C: D0 1C     BNE IRQ_BLINK       ; No, skip
$066E: A9 00     LDA #$00            ; Yes, reset seconds
$0670: 85 15     STA RTC_SECS
$0672: E6 16     INC RTC_MINS        ;Increment Minutes
$0674: A5 16     LDA RTC_MINS
$0676: C9 3C     CMP #$3C            ;Have we reached 60 minutes?
$0678: D0 10     BNE IRQ_BLINK       ; No, skip
$067A: A9 00     LDA #$00            ; Yes, reset minutes
$067C: 85 16     STA RTC_MINS
$067E: E6 17     INC RTC_HOURS       ;Increment hours
$0680: A5 17     LDA RTC_HOURS
$0682: C9 18     CMP #$18            ;Have we reached 24 hours
$0684: D0 04     BNE IRQ_BLINK       ; No, skip
$0686: A9 00     LDA #$00            ; Yes, reset hours
$0688: 85 17     STA RTC_HOURS

IRQ_BLINK:
;Blink the cursor
$068A: A5 06     LDA CURSOR_OFF      ;Is the cursor off?
$068C: D0 11     BNE IRQ_REPEAT      ;  Yes: skip cursor blink
$068E: C6 01     DEC BLINK_CNT       ;Decrement cursor blink countdown
$0690: D0 0D     BNE IRQ_REPEAT      ;Not time to blink? Done.
$0692: A9 14     LDA #$14
$0694: 85 01     STA BLINK_CNT       ;Reset cursor blink countdown
$0696: 20 88 09  JSR CALC_SCRLINE
$0699: B1 02     LDA (SCRLINE_LO),Y  ;Read character at cursor
$069B: 49 80     EOR #$80            ;Flip the REVERSE bit
$069D: 91 02     STA (SCRLINE_LO),Y  ;Write it back

IRQ_REPEAT:
;Repeat key handling
$069F: AD 37 0B  LDA SCANCODE        ;Get the SCANCODE
$06A2: CD 3E 0B  CMP REPEATCODE      ;Compare to SAVED scancode
$06A5: F0 0A     BEQ L_06B1          ;They are the same, so continue
$06A7: 8D 3E 0B  STA REPEATCODE      ;if not, save it
$06AA: A9 10     LDA #$10            ;reset counter
$06AC: 8D 3C 0B  STA REPEATCOUNT0    ;save to counter
$06AF: D0 21     BNE IRQ_SCAN
L_06B1:
$06B1: C9 FF     CMP #$FF            ; NO KEY?
$06B3: F0 1D     BEQ IRQ_SCAN        ; Yes, jump to scan for another
$06B5: AD 3C 0B  LDA REPEATCOUNT0    ; No, there was a key, so get the counter
$06B8: F0 05     BEQ L_06BF          ; Is it zero?
$06BA: CE 3C 0B  DEC REPEATCOUNT0    ; Count Down
$06BD: D0 13     BNE IRQ_SCAN         ; Is it Zero
L_06BF:
$06BF: CE 3D 0B  DEC REPEATCOUNT1    ; Count Down
$06C2: D0 0E     BNE IRQ_SCAN        ; Is it zero? No, scan for another
$06C4: A9 04     LDA #$04            ; Yes, Reset it to 4
$06C6: 8D 3D 0B  STA REPEATCOUNT1    ; Store it
$06C9: A9 00     LDA #$00            ;Clear the SCANCODE and allow the key to be processed
$06CB: 8D 37 0B  STA SCANCODE        ;Store it
$06CE: A9 02     LDA #$02
$06D0: 85 01     STA BLINK_CNT       ;Fast cursor blink(?)

IRQ_SCAN:
;Scan the keyboard
$06D2: 20 D4 09  JSR SCAN_KEYB       ;Scan the keyboard
                                     ;  An important side effect of SCAN_KEYB is
                                     ;  that it reads PIA1_COL.  The read clears
                                     ;  PIA #1's IRQB1 flag (50/60 Hz interrupt).
                                     ;  If this read is not performed, IRQ will
                                     ;  continuously retrigger.
$06D5: F0 0B     BEQ IRQ_DONE        ;Nothing to do if no key was pressed.
$06D7: A6 08     LDX KEYCOUNT
$06D9: E0 50     CPX #$50            ;Is the keyboard buffer full?
$06DB: F0 05     BEQ IRQ_DONE        ;  Yes:  Nothing we can do.  Forget the key.
$06DD: 9D 6F 02  STA KEYD,X          ;  No:   Store the key in the buffer
$06E0: E6 08     INC KEYCOUNT        ;        and increment the keycount.

IRQ_DONE:
$06E2: 68        PLA
$06E3: A8        TAY
$06E4: 68        PLA
$06E5: AA        TAX
$06E6: 68        PLA
$06E7: 40        RTI

PROCESS_BYTE:
;This is the core of the terminal emulator.  It accepts a byte in
;the accumulator, determines if it is a control code or character
;to display, and then jumps accordingly.  After the jump, all
;code paths will end up at PROCESS_DONE.
;
$06E8: 48        PHA
$06E9: A5 06     LDA CURSOR_OFF    ;Get the current cursor state
$06EB: 85 0C     STA CURSOR_TMP    ;  Remember it
$06ED: A9 FF     LDA #$FF
$06EF: 85 06     STA CURSOR_OFF    ;Hide the cursor
$06F1: 20 88 09  JSR CALC_SCRLINE  ;Calculate screen RAM pointer
$06F4: A5 07     LDA SCRCODE_TMP   ;Get the screen code previously saved
$06F6: 91 02     STA (SCRLINE_LO),Y ;  Put it on the screen
$06F8: 68        PLA
$06F9: 25 13     AND CHAR_MASK     ;Mask off bits depending on char mode
$06FB: A6 0B     LDX MOVETO_CNT    ;More bytes to consume for a move-to seq?
$06FD: D0 16     BNE L_0715        ;  Yes: branch to jump to move-to handler
$06FF: C9 20     CMP #$20          ;Is this byte a control code?
$0701: B0 15     BCS L_0718        ;  No: branch to put char on screen
$0703: 0A        ASL A
$0704: AA        TAX
$0705: BD 1E 07  LDA CTRL_CODES,X  ;Load vector from control code table
$0708: 85 0D     STA TARGET_LO
$070A: BD 1F 07  LDA CTRL_CODES+1,X
$070D: 85 0E     STA TARGET_HI
$070F: 20 1B 07  JSR JUMP_CMD      ;Jump to vector to handle control code
$0712: 4C 8D 07  JMP PROCESS_DONE
L_0715:
$0715: 4C B8 09  JMP MOVE_TO       ;Jump to handle move-to sequence
L_0718:
$0718: 4C 99 07  JMP PUT_CHAR      ;Jump to put character on the screen
JUMP_CMD:
$071B: 6C 0D 00  JMP (TARGET_LO)   ;Jump to handle the control code

CTRL_CODES:
;Terminal control code dispatch table.  These control codes are based
;on the Lear Seigler ADM-3A terminal.  Some bytes that are unused on
;that terminal are used for other purposes here.
;
;                               ;Hex  Keyboard
$071E:           .WORD CTRL_00  ;00   CTRL-@    Do nothing
$0720:           .WORD CTRL_01  ;01   CTRL-A    Go to 8-bit character mode
$0722:           .WORD CTRL_02  ;02   CTRL-B    Go to 7-bit character mode
$0724:           .WORD CTRL_03  ;03   CTRL-C    Do nothing
$0726:           .WORD CTRL_04  ;04   CTRL-D    Set a TAB stop at current position
$0728:           .WORD CTRL_05  ;05   CTRL-E    Clear TAB stop at current position
$072A:           .WORD CTRL_06  ;06   CTRL-F    Clear all TAB stops
$072C:           .WORD CTRL_07  ;07   CTRL-G    Ring bell
$072E:           .WORD CTRL_08  ;08   CTRL-H    Cursor left
$0730:           .WORD CTRL_09  ;09   CTRL-I    Perform TAB
$0732:           .WORD CTRL_0A  ;0A   CTRL-J    Cursor down (Line feed)
$0734:           .WORD CTRL_0B  ;0B   CTRL-K    Cursor up
$0736:           .WORD CTRL_0C  ;0C   CTRL-L    Cursor right
$0738:           .WORD CTRL_0D  ;0D   CTRL-M    Carriage return
$073A:           .WORD CTRL_0E  ;0E   CTRL-N    Reverse video on
$073C:           .WORD CTRL_0F  ;0F   CTRL-O    Reverse video off
$073E:           .WORD CTRL_10  ;10   CTRL-P    Cursor off
$0740:           .WORD CTRL_11  ;11   CTRL-Q    Insert a blank line
$0742:           .WORD CTRL_12  ;12   CTRL-R    Scroll up one line
$0744:           .WORD CTRL_13  ;13   CTRL-S    Clear to end of line
$0746:           .WORD CTRL_14  ;14   CTRL-T    Clear to end of screen
$0748:           .WORD CTRL_15  ;15   CTRL-U    Go to uppercase mode
$074A:           .WORD CTRL_16  ;16   CTRL-V    Go to lowercase mode
$074C:           .WORD CTRL_17  ;17   CTRL-W    Set line spacing to tall
$074E:           .WORD CTRL_18  ;18   CTRL-X    Set line spacing to short
$0750:           .WORD CTRL_19  ;19   CTRL-Y    Cursor on
$0752:           .WORD CTRL_1A  ;1A   CTRL-Z    Clear screen
$0754:           .WORD CTRL_1B  ;1B   ESC       Move cursor to X,Y position
$0756:           .WORD CTRL_1C  ;1C   CTRL-/    Insert a space on current line
$0758:           .WORD CTRL_1D  ;1D   CTRL-]    Delete character at cursor
$075A:           .WORD CTRL_1E  ;1E   CTRL-^    Home cursor
$075C:           .WORD CTRL_1F  ;1F             Do nothing

CTRL_07:
;Ring bell
;
$075E: A9 07     LDA #$07     ;CHR$(7) = Bell
$0760: 4C D2 FF  JMP CHROUT   ;KERNAL

CTRL_18:
;Set line spacing to tall (the default spacing for lowercase graphic mode).
;The current graphic mode will not be changed.
;
$0763: AD 4C E8  LDA VIA_PCR  ;Remember current upper/lower graphic mode
$0766: 48        PHA
$0767: A9 0E     LDA #$0E     ;CHR$(14) = Switch to lowercase mode
$0769: 20 D2 FF  JSR CHROUT   ;  and set more vertical space between chars
$076C: 68        PLA
$076D: 8D 4C E8  STA VIA_PCR  ;Restore graphic mode
$0770: 60        RTS

CTRL_17:
;Set line spacing to short (the default spacing for uppercase graphic mode).
;The current graphic mode will not be changed.
;
$0771: AD 4C E8  LDA VIA_PCR  ;Remember current upper/lower graphic mode
$0774: 48        PHA
$0775: A9 8E     LDA #$8E     ;CHR$(142) = Switch to uppercase mode
$0777: 20 D2 FF  JSR CHROUT   ;  and set less vertical space between chars
$077A: 68        PLA
$077B: 8D 4C E8  STA VIA_PCR  ;Restore graphic mode
$077E: 60        RTS

CTRL_01:
;Go to 8-bit character mode
;See PUT_CHAR for how this mode is used to display CBM graphics.
;
$077F: A9 FF     LDA #$FF
$0781: 85 13     STA CHAR_MASK
$0783: 60        RTS

CTRL_02:
;Go to 7-bit character mode
;
$0784: A9 7F     LDA #$7F
$0786: 85 13     STA CHAR_MASK
$0788: 60        RTS

CTRL_00:
CTRL_03:
CTRL_1F:
;Do nothing
$0789: 60        RTS

PUTSCR_THEN_DONE:
;Put the screen code in the accumulator on the screen
;and then fall through to PROCESS_DONE.
;
$078A: 20 F4 07  JSR PUT_SCRCODE

PROCESS_DONE:
;This routine always returns to DO_TERMINAL except during init.
;
$078D: 20 88 09  JSR CALC_SCRLINE   ;Calculate screen RAM pointer
$0790: B1 02     LDA (SCRLINE_LO),Y ;Get the current character on the screen
$0792: 85 07     STA SCRCODE_TMP    ;  Remember it
$0794: A5 0C     LDA CURSOR_TMP     ;Get the previous state of the cursor
$0796: 85 06     STA CURSOR_OFF     ;  Restore it
$0798: 60        RTS

PUT_CHAR:
;Puts an ASCII (not PETSCII) character in the accumulator on the screen
;at the current CURSOR_X and CURSOR_Y position.  This routine first
;converts the character to its equivalent CBM screen code and then
;jumps out to print it to the screen.
;
;Bytes $00-7F (bit 7 off) always correspond to the 7-bit standard
;ASCII character set and are converted to the equivalent CBM screen code.
;
;Bytes $80-FF (bit 7 on) are a special extended mode that display
;the CBM graphics characters if the terminal is in 8-bit mode (CTRL_01):
;
;  Byte      Screen Code
;  $80-BF -> $40-7F
;  $C0-FF -> $40-7F
;
$0799: C9 40     CMP #$40              ;Is it < 64?
$079B: 90 ED     BCC PUTSCR_THEN_DONE  ;  Yes: done, put it on the screen
$079D: C9 60     CMP #$60              ;Is it >= 96?
$079F: B0 05     BCS L_07A6            ;  Yes: branch to L_07A6
$07A1: 29 3F     AND #$3F              ;Turn off bits 6 and 7
$07A3: 4C AC 07  JMP L_07AC            ;Jump to L_07AC
L_07A6:
$07A6: C9 80     CMP #$80              ;Is bit 7 set?
$07A8: B0 20     BCS L_07CA            ;  Yes: branch to L_07CA
$07AA: 29 5F     AND #$5F
L_07AC:
$07AC: AA        TAX
$07AD: 29 3F     AND #$3F              ;Turn off bit 7 and bit 6
$07AF: F0 15     BEQ L_07C6
$07B1: C9 1B     CMP #$1B
$07B3: B0 11     BCS L_07C6
$07B5: 8A        TXA
$07B6: 49 40     EOR #$40              ;Flip bit 6
$07B8: AA        TAX
$07B9: AD 4C E8  LDA VIA_PCR           ;Bit 1 off = uppercase, on = lowercase
$07BC: 4A        LSR A
$07BD: 4A        LSR A
$07BE: B0 06     BCS L_07C6            ;Branch if lowercase mode
$07C0: 8A        TXA
$07C1: 29 1F     AND #$1F
$07C3: 4C 8A 07  JMP PUTSCR_THEN_DONE
L_07C6:
$07C6: 8A        TXA
$07C7: 4C 8A 07  JMP PUTSCR_THEN_DONE
L_07CA:
$07CA: 29 7F     AND #$7F              ;Turn off bit 7
$07CC: 09 40     ORA #$40              ;Turn on bit 6
$07CE: 4C 8A 07  JMP PUTSCR_THEN_DONE  ;Put it on the screen

CTRL_15:
;Go to uppercase mode
;
$07D1: A9 0C     LDA #$0C
$07D3: 8D 4C E8  STA VIA_PCR  ;Graphic mode = uppercase
$07D6: 60        RTS

CTRL_16:
;Go to lowercase mode
;
$07D7: A9 0E     LDA #$0E
$07D9: 8D 4C E8  STA VIA_PCR  ;Graphic mode = lowercase
$07DC: 60        RTS

CTRL_08:
;Cursor left
;
$07DD: A6 04     LDX CURSOR_X
$07DF: D0 08     BNE L_07E9     ; X > 0? Y will not change.
$07E1: A6 09     LDX X_WIDTH    ; X = max X + 1
$07E3: A5 05     LDA CURSOR_Y
$07E5: F0 05     BEQ L_07EC     ; Y=0? Can't move up.
$07E7: C6 05     DEC CURSOR_Y   ; Y=Y-1
L_07E9:
$07E9: CA        DEX
$07EA: 86 04     STX CURSOR_X   ; X=X-1
L_07EC:
$07EC: 60        RTS

CTRL_0B:
;Cursor up
;
$07ED: A4 05     LDY CURSOR_Y
$07EF: F0 FB     BEQ L_07EC     ; Y=0? Can't move up.
$07F1: C6 05     DEC CURSOR_Y   ; Y=Y-1
$07F3: 60        RTS

PUT_SCRCODE:
;Put the screen code in A on the screen at the current cursor position
;
$07F4: A6 0A     LDX REVERSE        ;Is reverse video mode on?
$07F6: F0 02     BEQ L_07FA         ;  No:  leave character alone
$07F8: 49 80     EOR #$80           ;  Yes: Flip bit 7 to reverse the character
L_07FA:
$07FA: 20 88 09  JSR CALC_SCRLINE   ;Calculate screen RAM pointer
$07FD: 91 02     STA (SCRLINE_LO),Y ;Write the character to the screen
                                    ;Fall through into CTRL_0C to advance cursor

CTRL_0C:
;Cursor right
;
$07FF: E6 04     INC CURSOR_X   ;X=X+1
$0801: A6 04     LDX CURSOR_X
$0803: E4 09     CPX X_WIDTH    ;X > max X?
$0805: D0 10     BNE L_0817     ;  No:  Done, no need to scroll up.
$0807: A9 00     LDA #$00       ;  Yes: Set X=0 and then
$0809: 85 04     STA CURSOR_X   ;       fall through into CTRL_0A to scroll.

CTRL_0A:
;Cursor down (Line feed)
;
$080B: A4 05     LDY CURSOR_Y
$080D: C0 18     CPY #$18       ;Are we on the bottom line?
$080F: D0 03     BNE L_0814     ;  No:  Increment Y, do not scroll up
$0811: 4C 8E 08  JMP SCROLL_UP  ;  Yes: Y remains unchanged, jump out to scroll
L_0814:
$0814: E6 05     INC CURSOR_Y   ;Increment Y position
$0816: 60        RTS
L_0817:
$0817: 60        RTS

CTRL_1E:
;Home cursor
;
$0818: A9 00     LDA #$00       ;Home cursor
$081A: 85 05     STA CURSOR_Y
$081C: 85 04     STA CURSOR_X
$081E: 60        RTS

CTRL_1A:
;Clear screen
;
$081F: A2 00     LDX #$00      ; Home cursor
$0821: 86 04     STX CURSOR_X
$0823: 86 05     STX CURSOR_Y
$0825: 86 0A     STX REVERSE   ;Reverse video off
$0827: A9 20     LDA #$20      ;Space character
L_0829:
$0829: 9D 00 80  STA SCREEN,X
$082C: 9D 00 81  STA SCREEN+$100,X
$082F: 9D 00 82  STA SCREEN+$200,X
$0832: 9D 00 83  STA SCREEN+$300,X
$0835: 9D 00 84  STA SCREEN+$400,X
$0838: 9D 00 85  STA SCREEN+$500,X
$083B: 9D 00 86  STA SCREEN+$600,X
$083E: 9D 00 87  STA SCREEN+$700,X
$0841: E8        INX
$0842: D0 E5     BNE L_0829
$0844: 60        RTS

CTRL_0D:
;Carriage return
;
$0845: A9 00     LDA #$00       ;Move to X=0 on this line
$0847: 85 04     STA CURSOR_X
$0849: 60        RTS

CTRL_10:
;Cursor on
;
$084A: A9 00     LDA #$00
$084C: 85 0C     STA CURSOR_TMP
$084E: 60        RTS

CTRL_19:
;Cursor off
;
$084F: A9 FF     LDA #$FF
$0851: 85 0C     STA CURSOR_TMP
$0853: 60        RTS

CTRL_0E:
;Reverse video on
;
$0854: A9 01     LDA #$01
$0856: 85 0A     STA REVERSE
$0858: 60        RTS

CTRL_0F:
;Reverse video off
;
$0859: A9 00     LDA #$00
$085B: 85 0A     STA REVERSE
$085D: 60        RTS

CTRL_13:
;Clear to end of line
;
$085E: 20 88 09  JSR CALC_SCRLINE   ;Leaves CURSOR_X in Y register
$0861: A9 20     LDA #$20           ;Space character
L_0863:
$0863: 91 02     STA (SCRLINE_LO),Y ;Write space to screen RAM
$0865: C8        INY                ;X=X+1
$0866: C4 09     CPY X_WIDTH
$0868: D0 F9     BNE L_0863         ;Loop until end of line
$086A: 60        RTS

CTRL_14:
;Clear from Current line to end of screen
;
$086B: 20 5E 08  JSR CTRL_13     ;Clear to the end of the current line
$086E: A6 05     LDX CURSOR_Y    ;Get the Current line#
L_0870:
$0870: E8        INX             ;Next Row
$0871: E0 19     CPX #$19        ;Is it 25 (last line of screen?
$0873: F0 18     BEQ L_088D      ;  Yes, we're done
$0875: 18        CLC             ;  No, continue
$0876: A5 02     LDA SCRLINE_LO  ;Current screen position
$0878: 65 09     ADC X_WIDTH     ;Add the line width
$087A: 85 02     STA SCRLINE_LO  ;Save it
$087C: 90 02     BCC L_0880      ;Need to update HI?
$087E: E6 03     INC SCRLINE_HI  ;  Yes, increment HI pointer
L_0880:
$0880: A9 20     LDA #$20        ;SPACE
$0882: A0 00     LDY #$00        ;Position 0
L_0884:
$0884: 91 02     STA (SCRLINE_LO),Y ;Write a space
$0886: C8        INY                ;Next character
$0887: C4 09     CPY X_WIDTH        ;Is it end of line?
$0889: D0 F9     BNE L_0884         ;No, loop back for more on this line
$088B: F0 E3     BEQ L_0870         ;Yes, loop back for next line
L_088D:
$088D: 60        RTS

SCROLL_UP:
;Scroll the screen up one line
;
$088E: A9 00     LDA #$00
$0890: 85 02     STA SCRLINE_LO
$0892: A5 09     LDA X_WIDTH
$0894: 85 0D     STA TARGET_LO
$0896: A9 80     LDA #>SCREEN
$0898: 85 03     STA SCRLINE_HI
$089A: 85 0E     STA TARGET_HI
$089C: A2 18     LDX #$18

SCROLL:
$089E: A0 00     LDY #$00
L_08A0:
$08A0: B1 0D     LDA (TARGET_LO),Y
$08A2: 91 02     STA (SCRLINE_LO),Y
$08A4: C8        INY
$08A5: C4 09     CPY X_WIDTH
$08A7: D0 F7     BNE L_08A0
$08A9: A5 0D     LDA TARGET_LO
$08AB: 85 02     STA SCRLINE_LO
$08AD: 18        CLC
$08AE: 65 09     ADC X_WIDTH
$08B0: 85 0D     STA TARGET_LO
$08B2: A5 0E     LDA TARGET_HI
$08B4: 85 03     STA SCRLINE_HI
$08B6: 69 00     ADC #$00
$08B8: 85 0E     STA TARGET_HI
$08BA: CA        DEX
$08BB: D0 E1     BNE SCROLL
$08BD: A0 00     LDY #$00
$08BF: A9 20     LDA #$20          ;SPACE
L_08C1:
$08C1: 91 02     STA (SCRLINE_LO),Y
$08C3: C8        INY
$08C4: C4 09     CPY X_WIDTH
$08C6: D0 F9     BNE L_08C1
$08C8: 60        RTS

CTRL_04:
;Set TAB stop at current position
;
$08C9: A9 01     LDA #$01         ;1=TAB STOP yes
$08CB:           .BYT 2C          ;Falls through to become BIT $00A9

CTRL_05:
;Clear TAB stop at current position
;
$08CC: A9 00     LDA #$00         ;0=No TAB STOP
$08CE: A6 04     LDX CURSOR_X     ;Get cursor position
$08D0: 9D 3F 0B  STA TAB_STOPS,X  ;Clear the TAB at that position
$08D3: 60        RTS

CTRL_06:
;Clear ALL TAB STOPS
;
$08D4: A2 4F     LDX #$4F  ; 80 characters-1
$08D6: A9 00     LDA #$00  ; zero
L_08D8:
$08D8: 9D 3F 0B  STA TAB_STOPS,X  ;store in the buffer
$08DB: CA        DEX
$08DC: 10 FA     BPL L_08D8
$08DE: 60        RTS

CTRL_09:
;Perform TAB.  Move to next TAB STOP as indicated in the TAB_STOPS table.
;
$08DF: A6 04     LDX CURSOR_X
L_08E1:
$08E1: E8        INX               ; next position
$08E2: E0 50     CPX #$50          ; 80 characters?
$08E4: B0 07     BCS L_08ED        ; yes, exit
$08E6: BD 3F 0B  LDA TAB_STOPS,X   ; read from the TAB STOPS table
$08E9: F0 F6     BEQ L_08E1        ; is it zero? yes, loop again
$08EB: 86 04     STX CURSOR_X      ; no, we hit a STOP, so store the position
L_08ED:
$08ED: 60        RTS

CTRL_1C:
;Insert space at current cursor position
;
$08EE: 20 88 09  JSR CALC_SCRLINE
$08F1: A4 09     LDY X_WIDTH         ;number of characters on line
$08F3: 88        DEY
L_08F4:
$08F4: C4 04     CPY CURSOR_X
$08F6: F0 09     BEQ L_0901
$08F8: 88        DEY
$08F9: B1 02     LDA (SCRLINE_LO),Y  ;read a character from line
$08FB: C8        INY                 ;position to the right
$08FC: 91 02     STA (SCRLINE_LO),Y  ;write it back
$08FE: 88        DEY                 ;we are counting down to zero
$08FF: D0 F3     BNE L_08F4          ;loop for another character
L_0901:
$0901: A9 20     LDA #$20            ; SPACE
$0903: 91 02     STA (SCRLINE_LO),Y  ; Write it to current character position
$0905: 60        RTS

CTRL_1D:
;Delete a character
;
$0906: 20 88 09  JSR CALC_SCRLINE
$0909: A4 04     LDY CURSOR_X
L_090B:
$090B: C8        INY
$090C: C4 09     CPY X_WIDTH
$090E: F0 08     BEQ L_0918
$0910: B1 02     LDA (SCRLINE_LO),Y  ;read a character from the line
$0912: 88        DEY                 ;position to the left
$0913: 91 02     STA (SCRLINE_LO),Y  ;write it back
$0915: C8        INY                 ;we are counting UP
$0916: D0 F3     BNE L_090B          ;loop for another character
L_0918:
$0918: 88        DEY
$0919: A9 20     LDA #$20            ;SPACE
$091B: 91 02     STA (SCRLINE_LO),Y  ;write it to the current character position
$091D: 60        RTS

CTRL_12:
;Scroll up one line
;
;The screen is shifted upward so that each line Y+1 is copied into Y.  Screen
;contents are preserved except for the bottommost line, which is erased
;(filled with spaces).  The current cursor position will not be changed.
;
$091E: A9 00     LDA #$00
$0920: 85 04     STA CURSOR_X
$0922: 20 88 09  JSR CALC_SCRLINE
$0925: A5 02     LDA SCRLINE_LO
$0927: 18        CLC
$0928: 65 09     ADC X_WIDTH
$092A: 85 0D     STA TARGET_LO
$092C: A5 03     LDA SCRLINE_HI
$092E: 69 00     ADC #$00
$0930: 85 0E     STA TARGET_HI
$0932: A9 18     LDA #$18
$0934: 38        SEC
$0935: E5 05     SBC CURSOR_Y
$0937: AA        TAX
$0938: 4C 9E 08  JMP SCROLL

CTRL_11:
;Insert a blank line
;
;The screen is shifted downward so that each line Y is copied into Y+1.
;The line at the current position will be erased (filled with spaces).
;The current cursor position will not be changed.
;
$093B: A9 C0     LDA #<SCREEN+$03C0 ;A->TARGET_LO, Y->TARGET_HI
$093D: A0 83     LDY #>SCREEN+$03C0 ;Start address of last 40 col line
$093F: A6 09     LDX X_WIDTH
$0941: E0 50     CPX #$50           ;Is this an 80 column screen?
$0943: D0 04     BNE L_0949         ;  No: keep address for 40 col
$0945: A9 80     LDA #<SCREEN+$0780
$0947: A0 87     LDY #>SCREEN+$0780 ;Start address of last 80 col line
L_0949:
$0949: 85 0D     STA TARGET_LO
$094B: 84 0E     STY TARGET_HI
$094D: A9 00     LDA #$00
$094F: 85 04     STA CURSOR_X
L_0951:
$0951: A5 0D     LDA TARGET_LO
$0953: C5 02     CMP SCRLINE_LO
$0955: D0 06     BNE L_095D
$0957: A5 0E     LDA TARGET_HI
$0959: C5 03     CMP SCRLINE_HI
$095B: F0 1F     BEQ L_097C
L_095D:
$095D: A5 0D     LDA TARGET_LO
$095F: 85 0F     STA INSERT_LO
$0961: 38        SEC
$0962: E5 09     SBC X_WIDTH
$0964: 85 0D     STA TARGET_LO
$0966: A5 0E     LDA TARGET_HI
$0968: 85 10     STA INSERT_HI
$096A: E9 00     SBC #$00
$096C: 85 0E     STA TARGET_HI
$096E: A0 00     LDY #$00
L_0970:
$0970: B1 0D     LDA (TARGET_LO),Y
$0972: 91 0F     STA (INSERT_LO),Y
$0974: C8        INY
$0975: C4 09     CPY X_WIDTH
$0977: D0 F7     BNE L_0970
$0979: 4C 51 09  JMP L_0951
L_097C:
$097C: A0 00     LDY #$00
$097E: A9 20     LDA #$20          ;SPACE
L_0980:
$0980: 91 02     STA (SCRLINE_LO),Y
$0982: C8        INY
$0983: C4 09     CPY X_WIDTH
$0985: D0 F9     BNE L_0980
$0987: 60        RTS

CALC_SCRLINE:
;Calculate a new pointer (scrline) to the first byte of the current
;line in screen RAM by multiplying cursor_y by 40 or 80.
;
;Preserves A and X.
;Returns cursor_x in Y.
;
$0988: 48        PHA
$0989: A9 00     LDA #$00
$098B: 85 03     STA SCRLINE_HI      ;Initialize high byte to zero
$098D: A5 05     LDA CURSOR_Y
$098F: 85 02     STA SCRLINE_LO      ;Initialize low byte to row number (Y-pos)

                                     ;Multiply by ( 2 * 2 + 1 ) * 2 * 2 * 2 = 40
$0991: 0A        ASL A               ;  * 2
$0992: 0A        ASL A               ;  * 2
$0993: 65 02     ADC SCRLINE_LO      ;  + 1
$0995: 0A        ASL A               ;  * 2
$0996: 0A        ASL A               ;  * 2
$0997: 26 03     ROL SCRLINE_HI      ;  Rotate any carry into high byte
$0999: 0A        ASL A               ;  * 2
$099A: 26 03     ROL SCRLINE_HI      ;  Rotate any additional carry into high byte
$099C: 85 02     STA SCRLINE_LO      ;  Save row number (Y-pos) multiplied by 40

$099E: A5 09     LDA X_WIDTH
$09A0: C9 50     CMP #$50            ;80 columns?
$09A2: D0 04     BNE L_09A8          ;  No: done multiplying
$09A4: 06 02     ASL SCRLINE_LO
$09A6: 26 03     ROL SCRLINE_HI      ;  Yes: multiply by 2 again

L_09A8:
$09A8: 18        CLC                 ;Add screen base address to high byte
$09A9: A4 04     LDY CURSOR_X
$09AB: A5 03     LDA SCRLINE_HI
$09AD: 69 80     ADC #>SCREEN
$09AF: 85 03     STA SCRLINE_HI

$09B1: 68        PLA                 ;Return with column (X-pos) in Y register
$09B2: 60        RTS

CTRL_1B:
;Move cursor to X,Y position
;
;This control code is unlike the others because it requires an
;additional two bytes to follow: first X-position, then Y-position.
;
;The MOVETO_CNT byte counts down the remaining bytes to consume.  On
;successive passes through PROCESS_BYTE, the X and Y bytes are handled
;by MOVE_TO.
;
;Note: The X and Y values use the same layout as CURSOR_X and CURSOR_Y
;but they require an offset.  You must add decimal 32 to each value to
;get the equivalent CURSOR_X and CURSOR_Y.  The offset is because this
;emulates the behavior of the Lear Siegler ADM-3A terminal.
;
$09B3: A9 02     LDA #$02          ;Two more bytes to consume (X-pos, Y-pos)
$09B5: 85 0B     STA MOVETO_CNT    ;Store count for next pass of PROCESS_BYTE
$09B7: 60        RTS

MOVE_TO:
;Implements CTRL_1B by handling the X-position byte on the first call
;and the Y-position byte on the second call.  After the Y-position byte
;has been consumed, MOVETO_CNT = 0, exiting the move-to sequence.
;
$09B8: C6 0B     DEC MOVETO_CNT    ;Decrement bytes remaining to consume
$09BA: F0 0C     BEQ L_09C8        ;Already got X pos?  Handle this byte as Y.
$09BC: 38        SEC
$09BD: E9 20     SBC #$20          ;X-pos = X-pos - #$20
$09BF: C5 09     CMP X_WIDTH       ;Requested X position out of range?
$09C1: B0 02     BCS L_09C5        ;  Yes: Do nothing.
$09C3: 85 04     STA CURSOR_X      ;  No:  Move cursor to requested X.
L_09C5:
$09C5: 4C 8D 07  JMP PROCESS_DONE  ;Done.
L_09C8:
$09C8: 38        SEC
$09C9: E9 20     SBC #$20          ;Y-pos = Y-pos - #$20
$09CB: C9 19     CMP #$19          ;Requested Y position out of range?
$09CD: B0 F6     BCS L_09C5        ;  Yes: Do nothing.
$09CF: 85 05     STA CURSOR_Y      ;  No:  Move cursor to requested Y.
$09D1: 4C 8D 07  JMP PROCESS_DONE  ;Done.

SCAN_KEYB:
;Scan the keyboard.
; The PET/CBM uses a 10x8 keyboard matrix. There are 10 rows, and 8 columns.
; To scan you select a ROW by writing the ROW NUMBER to the PIA1_ROW register. The lower 4 bits are sent to
; a 4 to 10 decoder. Then the PAI1COL register is read and each of the 8 bits represent one key in that row.
; IMPORTANT!!!! If a key is PRESSED the BIT will be ZERO.
; There are two keyboard tables which consists of 80 bytes each.
; One for "Graphic" (40 column) and one for "Business" (80 column).
;
; USES: SCANCODE  - Code of Pressed KEY ($FF=NONE)
;       LASTCODE  - Code of Previous KEY
;       ROWCOUNT  - Keyboard ROW counter
;       SHIFTFLAG - Shift Flag
;       KEYFLAG   - Regular Key Flag
;
$09D4: AD 37 0B  LDA SCANCODE           ;Old SCANCODE
$09D7: 8D 38 0B  STA LASTCODE           ;Save It
$09DA: A2 00     LDX #$00               ;X=0 Index into Keyboard Scan Table
$09DC: 8E 3A 0B  STX SHIFTFLAG          ;Reset Shift Flag
$09DF: 8E 3B 0B  STX KEYFLAG            ;Reset Key Flag

$09E2: 8E 10 E8  STX PIA1_ROW           ;Select a keyboard ROW
$09E5: A9 FF     LDA #$FF               ;$FF = no key
$09E7: 8D 37 0B  STA SCANCODE           ;Set it
$09EA: A9 0A     LDA #$0A               ;Keyboard has 10 ROWS
$09EC: 8D 39 0B  STA ROWCOUNT           ;ROW=10 - Keyboard ROW counter

;---- top of loop for keyboard ROWS
;
SCAN_ROW:
$09EF: A0 08     LDY #$08               ;Y=8 -- 8 Columns in Table

DEBOUNCE:
$09F1: AD 12 E8  LDA PIA1_COL           ;PIA#1 Keyboard Columns Read
$09F4: CD 12 E8  CMP PIA1_COL           ;PIA#1 Keyboard Columns Read
$09F7: D0 F8     BNE DEBOUNCE           ;wait for stable value on keyboard switches (debounce)
                                        ;Result of Row scan is now in A (call is SCANCODE)

;---- top of loop to go through each bit returned from scan. Each "0" bit represents a key pressed down

SCAN_COL:
$09F9: 4A        LSR A                  ;Shift byte RIGHT leaving CARRY flag set if it is a "1"
$09FA: 48        PHA                    ;Push it to the stack
$09FB: B0 22     BCS NEXTCOL            ;Is the BIT a "1"? Yes. Means key was NOT pressed. Bypass testing
$09FD: A5 09     LDA X_WIDTH            ; No, Need to check it.Check the terminal width
$09FF: C9 50     CMP #$50               ;Is this an 80 column screen?
$0A01: D0 06     BNE SKIP40
$0A03: BD E7 0A  LDA BUSINESS_KEYS,X    ;  Yes, read from Business keyboard table
$0A06: 4C 0C 0A  JMP GOT_ROW
SKIP40:
$0A09: BD 97 0A  LDA GRAPHICS_KEYS,X    ;  No,  read from Graphics keyboard table

GOT_ROW:
$0A0C: C9 01     CMP #$01               ;IS it the SHIFT key?
$0A0E: F0 07     BEQ KEY_SHIFT          ; Yes, skip
$0A10: 90 0A     BCC KEY_REG            ; No, It's a regular key
$0A12: 8D 37 0B  STA SCANCODE           ;Store the SCANCODE as-is
$0A15: B0 08     BCS NEXTCOL

KEY_SHIFT:
$0A17: EE 3A 0B  INC SHIFTFLAG          ;Increment SHIFT Flag
$0A1A: D0 03     BNE NEXTCOL            ; Is it >0? Yes, loop back for another key

KEY_REG:
$0A1C: EE 3B 0B  INC KEYFLAG            ;Increment KEY flag

NEXTCOL:
$0A1F: 68        PLA                    ;pull the original scan value from stack
$0A20: E8        INX                    ;X=X+1 - next entry in table
$0A21: 88        DEY                    ;Y=Y-1 - next BIT in scan value
$0A22: D0 D5     BNE SCAN_COL           ;Is it ZERO? No, go back for next COL

NEXTROW:
$0A24: EE 10 E8  INC PIA1_ROW           ;Increment Keyboard scanning ROW register - PIA#1 Keyboard Row Select
$0A27: CE 39 0B  DEC ROWCOUNT           ;ROW=ROW-1
$0A2A: D0 C3     BNE SCAN_ROW           ;Is ROW > 0 ? Yes, loop back up for next ROW

;-------------------------------------- end of scanning loops
; Check if there is anything to do. SCANCODE will be $FF if no key.
; If the SCANCODE = LASTCODE then key is being held down. Don't do anything until it is released.
; The IRQ handler implements key repeat by clearing the SCANCODE after a short interval.

$0A2C: AD 37 0B  LDA SCANCODE           ;Get the current SCANCODE
$0A2F: C9 FF     CMP #$FF               ;Is it NO KEY?
$0A31: F0 22     BEQ KEYDONE            ; Yes, exit

$0A33: CD 38 0B  CMP LASTCODE           ;Is it the same as last? (Key is registered on key UP?)
$0A36: F0 1D     BEQ KEYDONE            ; Yes, exit

;---- Check for CTRL key
KEY_CHECK1:
$0A38: C9 00     CMP #$00               ;Compare to CTRL key
$0A3A: 10 0A     BPL KEY_LOW            ;No, skip

;---- CTRL KEY not pressed
KEY_HI:
$0A3C: 29 7F     AND #$7F               ;Remove the TOP bit (shift flag for character?)
$0A3E: AC 3A 0B  LDY SHIFTFLAG          ;Check SHIFT Flag
$0A41: F0 03     BEQ KEY_LOW            ;SHIFT=0? Yes, skip
$0A43: 49 10     EOR #$10               ;No, flip BIT 4 (what does bit 4 do?)
$0A45: 60        RTS

;---- Check if in A-Z range
KEY_LOW:
$0A46: C9 40     CMP #$40               ;Start of compare to A-Z Range. "@" is lower limit?
$0A48: 90 25     BCC KEY_CHECK2         ;It is below? Yes, must be COMMAND character
$0A4A: C9 60     CMP #$60               ;Compare to upper ascii limit?
$0A4C: B0 21     BCS KEY_CHECK2         ;Is it above the A-Z range? Yes, skip

;----  Check KEY Flag
$0A4E: AC 3B 0B  LDY KEYFLAG            ;Check KEY Flag
$0A51: F0 03     BEQ KEY_ATOZ           ;Is it zero? Yes, skip
$0A53: 29 1F     AND #$1F               ;RETURN CTRL-A to Z - Use only the lower 5 BITS (0 to 31)

KEYDONE:
$0A55: 60        RTS

;---- Check A to Z or CTRL key
KEY_ATOZ:
$0A56: C9 40     CMP #$40               ;Compare to "@" symbol
$0A58: F0 15     BEQ KEY_CHECK2
$0A5A: C9 5B     CMP #$5B               ;Compare to "[" symbol?
$0A5C: B0 11     BCS KEY_CHECK2

$0A5E: AC 3A 0B  LDY SHIFTFLAG          ;Is SHIFT Flag set?
$0A61: D0 0C     BNE KEY_CHECK2         ; No,skip to next test

;---- Handle regular A-Z
$0A63: 48        PHA                    ;Yes, push the character code to stack
$0A64: AD 4C E8  LDA VIA_PCR            ;Bit 1 off = uppercase, on = lowercase
$0A67: 4A        LSR A                  ;shift
$0A68: 4A        LSR A                  ;shift to get BIT 2
$0A69: 68        PLA                    ;pull the character code from stack
$0A6A: 90 03     BCC KEY_CHECK2         ;Branch if uppercase mode
$0A6C: 09 20     ORA #$20               ;Convert character to UPPERCASE HERE
$0A6E: 60        RTS                    ;Return with character code in A

;---- Check SHIFT flag
KEY_CHECK2:
$0A6F: AC 3A 0B  LDY SHIFTFLAG          ;Check SHIFT flag for zero
$0A72: F0 20     BEQ KEY_SET            ;  Yes, skip out

;---- Translate SHIFTED 0-31 codes to terminal control codes
KEY_SH_CODES:
$0A74: A2 0B     LDX #$0B               ;CTRL_0B Cursor up
$0A76: C9 0A     CMP #$0A               ;SCAN=CRSR DOWN
$0A78: F0 18     BEQ KEY_CTRL_CODE
$0A7A: A2 08     LDX #$08               ;CTRL_08 Cursor left
$0A7C: C9 0C     CMP #$0C               ;SCAN=CRSR RIGHT
$0A7E: F0 12     BEQ KEY_CTRL_CODE
$0A80: A2 1A     LDX #$1A               ;CTRL_1A Clear screen
$0A82: C9 1E     CMP #$1E               ;SCAN=HOME
$0A84: F0 0C     BEQ KEY_CTRL_CODE

;---- these must be normal shifted keys or Graphics?
$0A86: 48        PHA                    ;Push key to stack
$0A87: AD 4C E8  LDA VIA_PCR            ;Bit 1 off = uppercase, on = lowercase
$0A8A: 4A        LSR A                  ;shift
$0A8B: 4A        LSR A                  ;shift - check bit 1
$0A8C: 68        PLA                    ;Pull original key from stack
$0A8D: B0 05     BCS KEY_SET            ;Branch if lowercase mode

$0A8F: 09 80     ORA #$80               ;Set the HIGH BIT
$0A91: 60        RTS                    ;Return with character code in A?

;---- Return a terminal control code (CTRL_CODES table)
KEY_CTRL_CODE:
$0A92: 8A        TXA                    ;Substitute the terminal control code
$0A93: 60        RTS                    ;Return with control code in A

KEY_SET:
$0A94: C9 00     CMP #$00               ;Set CARRY if non-zero character?
$0A96: 60        RTS


;40-column graphics keyboard table               ----- ----- ----- ----- ----- ----- ----- -----    Notes
GRAPHICS_KEYS:
$0A97:           .BYT 21,23,25,26,28,5F,1E,0C  ; !     #     %     &     (     BARRW HOME  RIGHT    BARRW= Back Arrow
$0A9F:           .BYT 22,24,27,5C,29,FF,0A,7F  ; "     $     '     \     )     NONE  CSRDN DEL      NONE = No key
$0AA7:           .BYT 51,45,54,55,4F,5E,37,39  ; Q     E     T     U     O     ^     7     9
$0AAF:           .BYT 57,52,59,49,50,FF,38,2F  ; W     R     Y     I     P     NONE  8     /
$0AB7:           .BYT 41,44,47,4A,4C,FF,34,36  ; A     D     G     J     L     NONE  4     6
$0ABF:           .BYT 53,46,48,4B,3A,FF,35,2A  ; S     F     H     K     :     NONE  5     *
$0AC7:           .BYT 5A,43,42,4D,3B,0D,31,33  ; Z     C     B     M     ;     RETRN 1     3
$0ACF:           .BYT 58,56,4E,2C,3F,FF,32,2B  ; X     V     N     ,     ?     NONE  2     +
$0AD7:           .BYT 01,40,5D,FF,3E,01,30,2D  ; SHIFT @     ]     NONE  >     SHIFT 0     -        SHIFT= $01
$0ADF:           .BYT 00,5B,20,3C,1B,FF,2E,3D  ; RVS   [     SPACE >     STOP  NONE  .     =        RVS  = $00 (CTRL key)

;80-column business keyboard table               ----- ----- ----- ----- ----- ----- ----- -----
BUSINESS_KEYS:
$0AE7:           .BYT B2,B5,B8,AD,38,0C,FF,FF  ; ^2    ^5    ^8    -     8     CSRRT NONE  NONE     UARROW = Up Arrow
$0AEF:           .BYT B1,B4,B7,30,37,5E,FF,39  ; ^1    ^4    ^7    0     7     UARRW NONE  9
$0AF7:           .BYT 1B,53,46,48,5D,4B,BB,35  ; ESC   S     F     H     ]     K     ;     5        ^ = Bit 7 is set,
$0AFF:           .BYT 41,44,47,4A,0D,4C,40,36  ; A     D     G     J     RTRN  L     @     6            indicating the
$0B07:           .BYT 09,57,52,59,5C,49,50,7F  ; TAB   W     R     Y     \     I     P     DEL          key shifts to a
$0B0F:           .BYT 51,45,54,55,0A,4F,5B,34  ; Q     E     T     U     CSRDN O     [     4            special character
$0B17:           .BYT 01,43,42,AE,2E,FF,01,33  ; SHIFT C     B     ^.    .     NONE  SHIFT 3
$0B1F:           .BYT 5A,56,4E,AC,30,FF,FF,32  ; Z     V     N     ,     0     NONE  NONE  2
$0B27:           .BYT 00,58,20,4D,1E,FF,AF,31  ; RVS   X     SPACE M     HOME  NONE  ^/    1
$0B2F:           .BYT 5F,B3,B6,B9,FF,BA,FF,FF  ; BARRW ^3    ^6    ^9    STOP  ^:    NONE  NONE

;Storage locations used in keyboard scanning routine SCAN_KEYB
SCANCODE:
$0B37:           .BYT AA

LASTCODE:
$0B38:           .BYT AA

ROWCOUNT:
$0B39:           .BYT AA

SHIFTFLAG:
$0B3A:           .BYT AA

KEYFLAG:
$0B3B:           .BYT AA

REPEATCOUNT0:
$0B3C:           .BYT AA

REPEATCOUNT1:
$0B3D:           .BYT AA

REPEATCODE:
$0B3E:           .BYT AA

;Start of buffer used by control codes 05, 06, and 09
TAB_STOPS:
$0B3F:           .BYT AA,AA,AA,AA,AA,AA,AA,AA
$0B47:           .BYT AA,AA,AA,AA,AA,AA,AA,AA
$0B4F:           .BYT AA,AA,AA,AA,AA,AA,AA,AA
$0B57:           .BYT AA,AA,AA,AA,AA,AA,AA,AA
$0B5F:           .BYT AA,AA,AA,AA,AA,AA,AA,AA
$0B67:           .BYT AA,AA,AA,AA,AA,AA,AA,AA
$0B6F:           .BYT AA,AA,AA,AA,AA,AA,AA,AA
$0B77:           .BYT AA,AA,AA,AA,AA,AA,AA,AA
$0B7F:           .BYT AA,AA,AA,AA,AA,AA,AA,AA
$0B87:           .BYT AA,AA,AA,AA,AA,AA,AA,AA
$0B8F:           .BYT AA,AA,AA,AA,AA,AA,AA,AA
$0B97:           .BYT AA,AA,AA,AA,AA,AA,AA,AA
$0B9F:           .BYT AA,AA,AA,AA,AA,AA,AA,AA
$0BA7:           .BYT AA,AA,AA,AA,AA,AA,AA,AA
$0BAF:           .BYT AA,AA,AA,AA,AA,AA,AA,AA
$0BB7:           .BYT AA,AA,AA,AA,AA,AA,AA,AA
$0BBF:           .BYT AA,AA,AA,AA,AA,AA,AA,AA
$0BC7:           .BYT AA,AA,AA,AA,AA,AA,AA,AA
$0BCF:           .BYT AA,AA,AA,AA,AA,AA,AA,AA
$0BD7:           .BYT AA,AA,AA,AA,AA,AA,AA,AA
$0BDF:           .BYT AA,AA,AA,AA,AA,AA,AA,AA
$0BE7:           .BYT AA,AA,AA,AA,AA,AA,AA,AA
$0BEF:           .BYT AA,AA,AA,AA,AA,AA,AA,AA
$0BF7:           .BYT AA,AA,AA,AA,AA,AA,AA
