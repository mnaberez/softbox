# File xfer.asm
0000			;XFER.COM 
0000			;  Transfer files between CP/M and CBM DOS. 
0000			; 
0000			;Usage: 
0000			;  "XFER <filename>" 
0000			; 
0000			;A menu will be displayed with four different options.  The <filename> 
0000			;argument is always a CP/M filename.  It may be the source or destination 
0000			;file, depending on which option is selected: 
0000			; 
0000			;  1. Copy a sequential file from CP/M to CBM DOS 
0000			;      <filename> is the CP/M source filename 
0000			; 
0000			;  2. Copy a sequential file from CBM DOS to CP/M (do not insert linefeeds) 
0000			;      <filename> is the CP/M destination filename 
0000			; 
0000			;  3. Copy a BASIC program file from CBM DOS to CP/M 
0000			;      <filename> is the CP/M destination filename 
0000			; 
0000			;  4. Copy a sequential file from CBM DOS to CP/M (insert linefeeds) 
0000			;      <filename> is the CP/M destination filename 
0000			; 
0000			;After an option is selected, the program will prompt for additional 
0000			;information such as drive letters and the second filename. 
0000			; 
0000			;Options #2 and #4 are the same function, the only difference being 
0000			;whether or not a linefeed will be inserted after each carriage return. 
0000			; 
0000			;When a BASIC program is copied (#3), the program will be detokenized 
0000			;and stored on the CP/M filesystem as an ASCII file. 
0000			; 
0000			 
0000			warm:          equ  0000h ;Warm start entry point 
0000			bdos:          equ  0005h ;BDOS entry point 
0000			fcb:           equ  005ch ;BDOS default FCB 
0000			dma_buf:       equ  0080h ;Default DMA buffer area (128 bytes) for disk I/O 
0000			eoisav:        equ 0ea6ch ;Stores ppi2_pa IEEE-488 ctrl lines after get byte 
0000			dos_msg:       equ 0eac0h ;Last error message returned from CBM DOS 
0000			ieee_listen:   equ 0f033h ;Send LISTEN to an IEEE-488 device 
0000			ieee_unlisten: equ 0f036h ;Send UNLISTEN to all IEEE-488 devices 
0000			ieee_talk:     equ 0f039h ;Send TALK to an IEEE-488 device 
0000			ieee_untalk:   equ 0f03ch ;Send UNTALK to all IEEE-488 devices 
0000			ieee_get_byte: equ 0f03fh ;Read byte from an IEEE-488 device 
0000			ieee_put_byte: equ 0f042h ;Send byte to an IEEE-488 device 
0000			get_dtype:     equ 0f051h ;Get drive type for a CP/M drive number 
0000			get_ddev:      equ 0f054h ;Get device address for a CP/M drive number 
0000			ieee_read_err: equ 0f05ah ;Read the error channel of an IEEE-488 device 
0000			ieee_open:     equ 0f05dh ;Open a file on an IEEE-488 device 
0000			ieee_close:    equ 0f060h ;Close an open file on an IEEE-488 device 
0000			ieee_init_drv: equ 0f078h ;Initialize an IEEE-488 disk drive 
0000			 
0000			cwrite:        equ 02h    ;Console Output 
0000			cwritestr:     equ 09h    ;Output String 
0000			creadstr:      equ 0ah    ;Buffered Console Input 
0000			fopen:         equ 0fh    ;Open File 
0000			fclose:        equ 10h    ;Close File 
0000			fdelete:       equ 13h    ;Delete File 
0000			fread:         equ 14h    ;Read Next Record 
0000			fwrite:        equ 15h    ;Write Next Record 
0000			fmake:         equ 16h    ;Create File 
0000			 
0000			lf:            equ 0ah    ;Line Feed 
0000			cr:            equ 0dh    ;Carriage Return 
0000			eof:           equ 1ah    ;End of File marker (CTRL-Z) 
0000			 
0000			    org 0100h             ;CP/M TPA 
0100			 
0100 00			    nop 
0101 00			    nop 
0102 00			    nop 
0103 ed 7b 06 00	    ld sp,(0006h) 
0107			 
0107 3a 5d 00		    ld a,(fcb+1)        ;A = first char in filename 
010a fe 20		    cp ' '              ;Is it a space? 
010c ca e1 03		    jp z,exit_bad_file  ;  Yes: exit with missing filename erro 
010f			 
010f 21 5d 00		    ld hl,fcb+1         ;HL = first char of filename 
0112 06 0b		    ld b,0bh            ;B = 11 chars in filename (8 chars + 3 chars ext) 
0114			check_wild: 
0114 7e			    ld a,(hl)           ;A = char in filename 
0115 fe 3f		    cp '?'              ;Is it a wildcard? 
0117 ca e1 03		    jp z,exit_bad_file  ;  Yes: exit with bad filename error 
011a 23			    inc hl              ;Increment HL to point to next char in filename 
011b 10 f7		    djnz check_wild     ;Decrement B, loop until all chars are checked 
011d			 
011d			get_selection: 
011d			;Show the menu options and get a selection 
011d			; 
011d cd 08 04		    call newline        ;Write newline to console out 
0120			 
0120 11 16 04		    ld de,menu          ;DE = address of main menu string 
0123 0e 09		    ld c,cwritestr      ;C = Output String 
0125 cd 05 00		    call bdos           ;BDOS system call 
0128			 
0128 cd b8 03		    call input          ;Get a line of user input 
012b 3a 5f 07		    ld a,(buffer+2)     ;A = first char from input 
012e			 
012e 21 e2 07		    ld hl,insert_lf     ;HL = address of insert linefeeds flag 
0131 36 00		    ld (hl),00h         ;Insert linefeeds flag = off 
0133			 
0133 fe 31		    cp '1'              ;1 = Copy sequential file to PET DOS 
0135 ca df 02		    jp z,seq_to_pet 
0138			 
0138 fe 32		    cp '2'              ;2 = Copy sequential file from PET DOS 
013a ca 52 01		    jp z,seq_from_pet 
013d			 
013d fe 33		    cp '3'              ;3 = Copy BASIC program from PET DOS 
013f ca 9f 01		    jp z,bas_from_pet 
0142			 
0142 34			    inc (hl)            ;Insert linefeeds flag = on 
0143			 
0143 fe 34		    cp '4'              ;4 = As 2. but insert line feeds 
0145 ca 52 01		    jp z,seq_from_pet 
0148			 
0148 11 a3 05		    ld de,bad_command   ;DE = address of bad command string 
014b 0e 09		    ld c,cwritestr      ;C = Output String 
014d cd 05 00		    call bdos           ;BDOS system call 
0150 18 cb		    jr get_selection    ;Try again 
0152			 
0152			seq_from_pet: 
0152			;Copy sequential file from PET DOS 
0152			; 
0152 3e 53		    ld a,'S'            ;A = 'S' for CBM DOS sequential file 
0154 cd 47 02		    call sub_0247h 
0157			 
0157 21 80 00		    ld hl,dma_buf 
015a			l015ah: 
015a cd a6 03		    call cbm_get_byte   ;Read a data byte from the CBM drive 
015d 57			    ld d,a              ;Save the byte in D 
015e			 
015e 3a 6c ea		    ld a,(eoisav)       ;A = ppi2_pa after get byte (IEEE-488 ctrl lines in) 
0161 e6 10		    and 10h             ;Mask off all except bit 4 (EOI in) 
0163 f5			    push af             ;Push EOI state onto the stack 
0164			 
0164 3a e2 07		    ld a,(insert_lf)    ;A = insert linefeeds flag 
0167 b7			    or a                ;Set flags 
0168 7a			    ld a,d              ;Recall data byte 
0169 28 09		    jr z,l0174h         ;Jump if insert linefeeds = off 
016b			 
016b fe 0d		    cp cr               ;Is the byte a carriage return? 
016d 20 05		    jr nz,l0174h        ;  No: jump over skip over LF insertion 
016f			 
016f cd 34 02		    call write_to_file  ;Write CR to file 
0172 3e 0a		    ld a,lf             ;A = linefeed 
0174			                        ;Fall through to write LF to file 
0174			 
0174			l0174h: 
0174 cd 34 02		    call write_to_file  ;Write byte to file 
0177			 
0177 f1			    pop af              ;Pop EOI state from the stack 
0178 28 e0		    jr z,l015ah         ;Loop for next byte if EOI=high indicating more data 
017a			                        ;  (IEEE-488 line states are inverted) 
017a			 
017a			l017ah: 
017a ed 5b e0 07	    ld de,(cbm_device)  ;D = IEEE-488 primary address, E = file number 
017e cd 60 f0		    call ieee_close     ;Close open file on IEEE-488 device 
0181			 
0181 06 7f		    ld b,7fh            ;B = number EOF filler bytes to write 
0183			l0183h: 
0183 c5			    push bc 
0184 3e 1a		    ld a,eof            ;A = End of File marker (CTRL-Z) 
0186 cd 34 02		    call write_to_file  ;Write EOF char to file 
0189 c1			    pop bc 
018a 10 f7		    djnz l0183h         ;Decrement B, loop until B=0 
018c			 
018c 11 5c 00		    ld de,fcb           ;DE = address of FCB 
018f 0e 10		    ld c,fclose         ;C = Close File 
0191 cd 05 00		    call bdos           ;BDOS system call 
0194			 
0194 11 dd 05		    ld de,complete      ;DE = address of "Transfer complete" 
0197 0e 09		    ld c,cwritestr      ;C = Output String 
0199 cd 05 00		    call bdos           ;BDOS system call 
019c			 
019c c3 00 00		    jp warm             ;Warm start 
019f			 
019f			bas_from_pet: 
019f			;Copy BASIC program from PET DOS 
019f			; 
019f 3e 50		    ld a,'P'            ;A = 'P' for CBM DOS program file 
01a1 cd 47 02		    call sub_0247h 
01a4			 
01a4 21 80 00		    ld hl,dma_buf       ;HL = address of DMA buffer 
01a7			 
01a7 cd a6 03		    call cbm_get_byte   ;Read start address low byte (discarded) 
01aa cd a6 03		    call cbm_get_byte   ;Read high byte (discarded) 
01ad			 
01ad			bas_line: 
01ad			;Process a tokenized line in the BASIC program. 
01ad			; 
01ad			                        ;Read pointer to next BASIC line: 
01ad cd a6 03		    call cbm_get_byte   ;  A = Read pointer to next BASIC line low byte 
01b0 f5			    push af             ;  Push it onto the stack 
01b1 cd a6 03		    call cbm_get_byte   ;  A = Read pointer to next BASIC line high byte 
01b4 c1			    pop bc              ;  B = pop pointer low byte from stack 
01b5			 
01b5			                        ;Detect end of BASIC program: 
01b5 b0			    or b                ;  Perform logical OR between the pointer bytes 
01b6 28 c2		    jr z,l017ah         ;  Jump to finish up if the pointer is zero. 
01b8			                        ;    (End of BASIC program reached) 
01b8			 
01b8 e5			    push hl             ;Push DMA address onto stack 
01b9			 
01b9			                        ;Read BASIC line number: 
01b9 cd a6 03		    call cbm_get_byte   ;  A = read low byte of BASIC line number 
01bc f5			    push af             ;  Save line number low byte on stack 
01bd cd a6 03		    call cbm_get_byte   ;  A = read high byte of BASIC line number 
01c0 57			    ld d,a              ;  Move it into D 
01c1 f1			    pop af              ;  Pop line number high byte from stack 
01c2 5f			    ld e,a              ;  Move it into E 
01c3			                        ;  BASIC line number is now in DE 
01c3			 
01c3 01 10 27		    ld bc,10000         ;Write the line number as decimal in ASCII 
01c6 cd 23 02		    call bas_num        ;  TODO: comment these 
01c9 01 e8 03		    ld bc,1000 
01cc cd 23 02		    call bas_num 
01cf 01 64 00		    ld bc,100 
01d2 cd 23 02		    call bas_num 
01d5 01 0a 00		    ld bc,10 
01d8 cd 23 02		    call bas_num 
01db 7b			    ld a,e 
01dc c6 30		    add a,30h           ;Convert it to ASCII 
01de cd 34 02		    call write_to_file  ;Write it out 
01e1			 
01e1 3e 20		    ld a,' ' 
01e3 cd 34 02		    call write_to_file  ;Write space after BASIC line number 
01e6			 
01e6			bas_char: 
01e6			;Get the next byte in the BASIC line and handle it.  The byte may 
01e6			;be a token, end of line marker (null byte), or other character. 
01e6			; 
01e6 cd a6 03		    call cbm_get_byte   ;Read next byte in BASIC line 
01e9 b7			    or a                ;Set flags 
01ea 28 08		    jr z,bas_eol        ;Jump if zero (indicates end of current BASIC line) 
01ec fa 00 02		    jp m,bas_token      ;Jump if bit 7 is set (indicates a BASIC token) 
01ef			 
01ef cd 34 02		    call write_to_file  ;Byte is not a token, so write it out as-is 
01f2 18 f2		    jr bas_char         ;Loop to get the next byte on this line 
01f4			 
01f4			bas_eol: 
01f4			;End of current BASIC line has been reached.  Write CRLF to the output 
01f4			;file and then loop to do the next line 
01f4			; 
01f4 3e 0d		    ld a,cr 
01f6 cd 34 02		    call write_to_file  ;Write carriage return 
01f9 3e 0a		    ld a,lf 
01fb cd 34 02		    call write_to_file  ;Write line feed 
01fe 18 ad		    jr bas_line         ;Loop to do the next line 
0200			 
0200			bas_token: 
0200			;The current byte in the line is a BASIC token.  Find the ASCII 
0200			;command text for the token in the basic4_cmds table and write 
0200			;it to the output file. 
0200			; 
0200 11 02 06		    ld de,basic4_cmds   ;DE = address of BASIC commands table 
0203 e6 7f		    and 7fh             ;Strip high bit from the token 
0205 47			    ld b,a              ;Move it into B 
0206 04			    inc b               ;Add one 
0207			 
0207			bas_find_tok: 
0207			;Loop until the BASIC command text for the token is found in the 
0207			;basic4_cmds table. 
0207			; 
0207 10 0f		    djnz bas_next_tok   ;Decrement B, loop until B=0 
0209			 
0209			bas_found_tok: 
0209			;The text for the current BASIC token has been found.  On entry, 
0209			;DE will be pointing at the first char of the command text. 
0209			;Write the command text to the output file. 
0209			; 
0209 1a			    ld a,(de)           ;A = char from BASIC commands table 
020a e6 7f		    and 7fh             ;Strip high bit 
020c d5			    push de 
020d cd 34 02		    call write_to_file  ;Write char from the command to file 
0210 d1			    pop de 
0211 1a			    ld a,(de)           ;A = same char from BASIC commands table 
0212 17			    rla                 ;Rotate bit 7 of command text into carry 
0213 13			    inc de              ;Increment pointer to commands table 
0214 30 f3		    jr nc,bas_found_tok ;Loop for next if more chars in command text 
0216 18 ce		    jr bas_char         ;Otherwise, this token is done, continue on 
0218			                        ;  to the next byte in the line. 
0218			 
0218			bas_next_tok: 
0218			;Advance the pointer in DE to the next command in the 
0218			;basic4_cmds table. 
0218			; 
0218 1a			    ld a,(de)           ;A = char from commands table 
0219 13			    inc de              ;Increment pointer to next char in command 
021a fe ff		    cp 0ffh             ;End of commands table reached? 
021c 28 c8		    jr z,bas_char       ;  Yes: forget this char, jump to read next byte 
021e 17			    rla                 ;Rotate to test bit 7 
021f 30 f7		    jr nc,bas_next_tok  ;Jump if bit 7 is not set (more chars in command) 
0221 18 e4		    jr bas_find_tok 
0223			 
0223			bas_num: 
0223			;DE = BASIC line number 
0223			; 
0223 e5			    push hl 
0224 eb			    ex de,hl 
0225 3e 2f		    ld a,2fh 
0227			l0227h: 
0227 3c			    inc a 
0228 b7			    or a 
0229 ed 42		    sbc hl,bc 
022b 30 fa		    jr nc,l0227h 
022d 09			    add hl,bc 
022e e3			    ex (sp),hl 
022f cd 34 02		    call write_to_file 
0232 d1			    pop de 
0233 c9			    ret 
0234			 
0234			write_to_file: 
0234			;Write the byte in A to the DMA buffer via the pointer in HL 
0234			;and advance the pointer.  When the DMA buffer is full, write it 
0234			;to the current CP/M file and then reset the pointer. 
0234			; 
0234 77			    ld (hl),a           ;Store byte in DMA buffer 
0235 2c			    inc l               ;Increment DMA buffer pointer 
0236 c0			    ret nz              ;Return if the buffer is not full 
0237			 
0237 11 5c 00		    ld de,fcb           ;DE = address of FCB 
023a 0e 15		    ld c,fwrite         ;C = Close File 
023c cd 05 00		    call bdos           ;BDOS system call 
023f b7			    or a                ;Set flags (A=0 means no error) 
0240 c2 d4 02		    jp nz,exit_full     ;Exit with "disk full" message if error 
0243			 
0243 21 80 00		    ld hl,dma_buf       ;Reset the pointer to the DMA pointer 
0246 c9			    ret 
0247			 
0247			sub_0247h: 
0247			;Called from seq_from_pet, bas_from_pet 
0247			; 
0247			;A = CBM DOS file type ('P'=program, 'S'=sequential) 
0247			; 
0247 f5			    push af             ;Push file type char onto stack 
0248			l0248h: 
0248 11 13 05		    ld de,ask_src_drive ;DE = address of "PET DOS source drive (A-P)?" 
024b 0e 09		    ld c,cwritestr      ;C = Output String 
024d cd 05 00		    call bdos           ;BDOS system call 
0250			 
0250 cd b8 03		    call input          ;Get a line of input from the user 
0253 3a 5f 07		    ld a,(buffer+2)     ;Take the first character from that input 
0256 d6 41		    sub 41h             ;Convert drive letter to number (A=0, B=1, C=2, ...) 
0258 32 df 07		    ld (src_drive),a    ;Save the source drive number 
025b cd 51 f0		    call get_dtype      ;Check if drive is valid (carry set = valid) 
025e 38 0a		    jr c,l026ah         ;Jump if drive is valid 
0260			 
0260 11 92 05		    ld de,bad_drive     ;DE = address of "Bad drive" 
0263 0e 09		    ld c,cwritestr      ;C = Output String 
0265 cd 05 00		    call bdos           ;BDOS system call 
0268			 
0268 18 de		    jr l0248h           ;Try again 
026a			 
026a			l026ah: 
026a 11 31 05		    ld de,ask_src_file  ;DE = address of "PET DOS source file? " 
026d 0e 09		    ld c,cwritestr      ;C = Output String 
026f cd 05 00		    call bdos           ;BDOS system call 
0272			 
0272 cd b8 03		    call input          ;Get a line of input from the user 
0275			 
0275 3a df 07		    ld a,(src_drive)    ;A = CP/M source drive number 
0278 cd 78 f0		    call ieee_init_drv  ;Initialize the CBM disk drive 
027b			 
027b			                        ;The buffer area now contains a CBM DOS filename. 
027b			                        ;The first two bytes of the buffer area are the total 
027b			                        ;buffer size (buffer+0) and bytes used (buffer+1). 
027b			                        ;These two bytes will be overwritten with a CBM drive 
027b			                        ;prefix ("0:" or "1:"). 
027b			 
027b 3a df 07		    ld a,(src_drive)    ;A = CP/M source drive number 
027e e6 01		    and 01h             ;Mask off all except bit one.  Bit 0 of the CP/M 
0280			                        ;  drive number indicates which drive in a 
0280			                        ;  CBM dual drive unit. 
0280 c6 30		    add a,30h           ;Convert it to ASCII (0="0", 1="1") 
0282 32 5d 07		    ld (buffer),a       ;Store the CBM drive number at buffer+0 
0285			 
0285 3a df 07		    ld a,(src_drive)    ;A = CP/M drive number 
0288 cd 54 f0		    call get_ddev       ;D = IEEE-488 primary address for the drive 
028b			                        ;  (D will be used below) 
028b			 
028b 21 5e 07		    ld hl,buffer+1      ;HL = address of buffer character count 
028e 7e			    ld a,(hl)           ;A = number of characters in buffer 
028f c6 06		    add a,06h           ;Add 6 characters to the count ("0:" + ",S,R") 
0291			 
0291 4f			    ld c,a              ;Move character count into C 
0292 36 3a		    ld (hl),':'         ;Store CBM drive number separator at buffer+1 
0294			 
0294 21 59 07		    ld hl,0759h 
0297 06 00		    ld b,00h            ;B = 0.  BC now holds number of chars in filename 
0299 09			    add hl,bc 
029a			 
029a 36 2c		    ld (hl),','         ;Append ',' 
029c 23			    inc hl 
029d f1			    pop af              ;Pop file type char off stack 
029e 77			    ld (hl),a           ;Append file type ('P' or 'S') 
029f 23			    inc hl 
02a0 36 2c		    ld (hl),','         ;Append ',' 
02a2 23			    inc hl 
02a3 36 52		    ld (hl),'R'         ;Append 'R' (Read mode) 
02a5			 
02a5 21 5d 07		    ld hl,buffer 
02a8			 
02a8 1e 03		    ld e,03h            ;E = file number 
02aa			                        ;D = primary address set in get_ddev call above 
02aa ed 53 e0 07	    ld (cbm_device),de  ;Store primary address and file number 
02ae cd 5d f0		    call ieee_open      ;Open a file on an IEEE-488 device 
02b1			 
02b1 3a df 07		    ld a,(src_drive)    ;A = CP/M source drive 
02b4 cd 5a f0		    call ieee_read_err  ;Read the CBM DOS error channel 
02b7 b7			    or a                ;Set flags (0=OK) 
02b8 c2 ec 03		    jp nz,exit_dos_err  ;Jump if the status is not OK 
02bb			 
02bb 11 5c 00		    ld de,fcb           ;DE = address of FCB 
02be 0e 13		    ld c,fdelete        ;C = Delete File 
02c0 cd 05 00		    call bdos           ;BDOS system call 
02c3			 
02c3 11 5c 00		    ld de,fcb           ;DE = address of FCB 
02c6 0e 16		    ld c,fmake          ;C = Create File 
02c8 cd 05 00		    call bdos           ;BDOS system call 
02cb 3c			    inc a               ;Increment to check error from fmake 
02cc			                        ;  (fmake returns A=0FFh if an error occurred) 
02cc c0			    ret nz              ;Return if an error occurred 
02cd			 
02cd ed 5b e0 07	    ld de,(cbm_device)  ;D = IEEE-488 primary address, E = file number 
02d1 cd 60 f0		    call ieee_close     ;Close open file on IEEE-488 device 
02d4			 
02d4			exit_full: 
02d4			;Print disk full error and return to CP/M 
02d4			; 
02d4 11 c4 05		    ld de,disk_full     ;DE = address of "Disk or directory full" 
02d7 0e 09		    ld c,cwritestr      ;C = Output String 
02d9 cd 05 00		    call bdos           ;BDOS system call 
02dc c3 00 00		    jp warm             ;Warm start 
02df			 
02df			seq_to_pet: 
02df			;Copy sequential file to PET DOS 
02df			; 
02df 11 48 05		    ld de,ask_dest_drv  ;DE = address of "PET DOS destination drive?" 
02e2 0e 09		    ld c,cwritestr      ;C = Ouput String 
02e4 cd 05 00		    call bdos           ;BDOS system call 
02e7			 
02e7 cd b8 03		    call input          ;Get a line of input from the user 
02ea 3a 5f 07		    ld a,(buffer+2)     ;Take the first character from that input 
02ed d6 41		    sub 41h             ;Convert drive letter to number (A=0, B=1, C=2, ...) 
02ef 32 df 07		    ld (src_drive),a    ;Save the source drive number 
02f2 cd 51 f0		    call get_dtype      ;Check if drive is valid (carry set = valid) 
02f5 38 0a		    jr c,l0301h         ;Jump if drive is valid 
02f7			 
02f7 11 92 05		    ld de,bad_drive     ;DE = address of "Bad drive" 
02fa 0e 09		    ld c,cwritestr      ;C = Output String 
02fc cd 05 00		    call bdos           ;BDOS system call 
02ff			 
02ff 18 de		    jr seq_to_pet       ;Try again 
0301			 
0301			l0301h: 
0301 11 6b 05		    ld de,ask_dest_file ;DE = address of "PET DOS destination file?" 
0304 0e 09		    ld c,cwritestr      ;C = Output String 
0306 cd 05 00		    call bdos           ;BDOS system call 
0309			 
0309 cd b8 03		    call input          ;Get a line of input from the user 
030c			 
030c 3a df 07		    ld a,(src_drive)    ;A = CP/M source drive 
030f cd 78 f0		    call ieee_init_drv  ;Initialize an IEEE-488 disk drive 
0312			 
0312 3a df 07		    ld a,(src_drive)    ;A = CP/M source drive number 
0315 e6 01		    and 01h             ;Mask off all except bit one.  Bit 0 of the CP/M 
0317			                        ;  drive number indicates which drive in a 
0317			                        ;  CBM dual drive unit. 
0317 c6 30		    add a,30h           ;Convert it to ASCII (0="0", 1="1") 
0319 32 5d 07		    ld (buffer),a       ;Save the CBM drive number 
031c			 
031c 3a df 07		    ld a,(src_drive)    ;A = CP/M source drive 
031f cd 54 f0		    call get_ddev       ;D = IEEE-488 primary address for the drive 
0322			                        ;  (D will be used below) 
0322			 
0322 21 5e 07		    ld hl,buffer+1 
0325 4e			    ld c,(hl) 
0326 06 00		    ld b,00h 
0328 dd 21 5f 07	    ld ix,buffer+2 
032c dd 09		    add ix,bc 
032e dd 36 00 2c	    ld (ix+00h),','     ;Append ',' 
0332 dd 36 01 53	    ld (ix+01h),'S'     ;Append 'S' (for Sequential file) 
0336 dd 36 02 2c	    ld (ix+02h),','     ;Append ',' 
033a dd 36 03 57	    ld (ix+03h),'W'     ;Append 'W' (for Write mode) 
033e 03			    inc bc 
033f 03			    inc bc 
0340 03			    inc bc 
0341 03			    inc bc 
0342 03			    inc bc 
0343 03			    inc bc 
0344 36 3a		    ld (hl),3ah 
0346 2b			    dec hl 
0347			 
0347 1e 03		    ld e,03h            ;E = file number 
0349			                        ;D = primary address set in get_ddev call above 
0349 ed 53 e0 07	    ld (cbm_device),de  ;Store primary address and file number 
034d cd 5d f0		    call ieee_open      ;Open a file on an IEEE-488 device 
0350			 
0350 3a df 07		    ld a,(src_drive)    ;A = CP/M source drive 
0353 cd 5a f0		    call ieee_read_err  ;Read the CBM DOS error channel 
0356 b7			    or a                ;Set flags (0=OK) 
0357 c2 ec 03		    jp nz,exit_dos_err  ;Jump if the status is not OK 
035a			 
035a			                        ;Open the CP/M input file: 
035a 11 5c 00		    ld de,fcb           ;  DE = address of FCB 
035d 0e 0f		    ld c,fopen          ;  C = Open File 
035f cd 05 00		    call bdos           ;  BDOS system call 
0362 3c			    inc a               ;  Increment to check error from fopen 
0363			                        ;    (fopen returns A=0FFh if an error occurred) 
0363 ca 9b 03		    jp z,exit_no_file   ;  Jump if an error occurred in fopen 
0366			 
0366			seq_next_record: 
0366			                        ;Read the next record from the CP/M input file: 
0366 11 5c 00		    ld de,fcb           ;  DE = address of FCB 
0369 0e 14		    ld c,fread          ;  C = Read Next Record 
036b cd 05 00		    call bdos           ;  BDOS system call 
036e b7			    or a                ;  Set flags (fread returns A=0 if OK) 
036f 20 18		    jr nz,seq_done      ;  Jump if an error occurred in fread 
0371			 
0371 ed 5b e0 07	    ld de,(cbm_device)  ;D = IEEE-488 primary address, E = file number 
0375 cd 33 f0		    call ieee_listen    ;Send LISTEN 
0378			 
0378			                        ;Send all bytes in the DMA buffer to CBM DOS: 
0378 21 80 00		    ld hl,dma_buf       ;  HL = address of DMA buffer 
037b			seq_dma_loop:           ; 
037b 7e			    ld a,(hl)           ;  A = get byte from the DMA buffer 
037c e5			    push hl             ; 
037d cd 42 f0		    call ieee_put_byte  ;  Send it to the drive 
0380 e1			    pop hl              ; 
0381 2c			    inc l               ;  Increment low byte of DMA buffer pointer 
0382 20 f7		    jr nz,seq_dma_loop  ;  Loop until L rolls over to 0, indicating that 
0384			                        ;    all 128 bytes in the DMA buffer have been sent 
0384			 
0384 cd 36 f0		    call ieee_unlisten  ;Send UNLISTEN 
0387 18 dd		    jr seq_next_record  ;Loop to do the next record 
0389			 
0389			seq_done: 
0389 ed 5b e0 07	    ld de,(cbm_device)  ;D = IEEE-488 primary address, E = file number 
038d cd 60 f0		    call ieee_close     ;Close open file on IEEE-488 device 
0390			 
0390 11 dd 05		    ld de,complete      ;DE = address of "Transfer complete" 
0393 0e 09		    ld c,cwritestr      ;C = Output String 
0395 cd 05 00		    call bdos           ;BDOS system call 
0398 c3 00 00		    jp warm             ;Warm start 
039b			 
039b			exit_no_file: 
039b			;Print file not found message and return to CP/M 
039b			; 
039b 11 f1 05		    ld de,not_found     ;DE = address of "File not found" 
039e 0e 09		    ld c,cwritestr      ;C = Output String 
03a0 cd 05 00		    call bdos           ;BDOS system call 
03a3 c3 00 00		    jp warm             ;Warm start 
03a6			 
03a6			cbm_get_byte: 
03a6			;Get the next byte from the CBM drive 
03a6			;Returns the byte in A. 
03a6			; 
03a6 e5			    push hl 
03a7 ed 5b e0 07	    ld de,(cbm_device)  ;D = IEEE-488 primary address, E = file number 
03ab cd 39 f0		    call ieee_talk      ;Send TALK 
03ae cd 3f f0		    call ieee_get_byte  ;Get byte 
03b1 f5			    push af 
03b2 cd 3c f0		    call ieee_untalk    ;Send UNTALK 
03b5 f1			    pop af 
03b6 e1			    pop hl 
03b7 c9			    ret 
03b8			 
03b8			input: 
03b8			;Read a line of input from the user and store it in the buffer. 
03b8			; 
03b8 11 5d 07		    ld de,buffer        ;DE = address of buffer to receive user input 
03bb 3e 50		    ld a,50h            ;A = 80 bytes available in the buffer 
03bd 12			    ld (de),a           ;Store bytes available where BDOS reads it 
03be 0e 0a		    ld c,creadstr       ;C = Buffered Console Input 
03c0 cd 05 00		    call bdos           ;BDOS system call 
03c3			 
03c3 cd 08 04		    call newline        ;Print a newline 
03c6			 
03c6 3a 5e 07		    ld a,(buffer+1)     ;A = number of characters in the buffer 
03c9 21 5f 07		    ld hl,buffer+2      ;HL = address of first char in the buffer 
03cc			 
03cc 47			    ld b,a              ;Move number of chars in buffer to B 
03cd 04			    inc b               ;Increment B 
03ce			 
03ce			l03ceh: 
03ce 7e			    ld a,(hl)           ;Get a char from the buffer 
03cf			 
03cf fe 61		    cp 61h              ;Set carry if A < 97, clear carry if A >= 97 
03d1 38 07		    jr c,l03dah         ;Jump if A < 97 (ASCII "a") 
03d3			 
03d3 fe 7b		    cp 7bh              ;Set carry if A < 123, clear carry if A >= 123 
03d5 30 03		    jr nc,l03dah        ;Jump if A >= 123 (ASCII "z" + 1) 
03d7			 
03d7			                        ;Char is in the range of 97 ("a") and 123 ("z"). 
03d7			 
03d7 d6 20		    sub 20h             ;Convert ASCII lowercase to uppercase 
03d9 77			    ld (hl),a           ;Save it back to the buffer 
03da			 
03da			l03dah: 
03da 23			    inc hl              ;Increment pointer to next char in the buffer 
03db 10 f1		    djnz l03ceh         ;Decrement B, loop until B=0 
03dd			 
03dd 2b			    dec hl 
03de 36 0d		    ld (hl),cr 
03e0 c9			    ret 
03e1			 
03e1			exit_bad_file: 
03e1			;Print bad filename message and return to CP/M. 
03e1			; 
03e1 11 82 05		    ld de,bad_filename  ;DE = address of "Bad filename" 
03e4 0e 09		    ld c,cwritestr      ;C = Output String 
03e6 cd 05 00		    call bdos           ;BDOS system call 
03e9 c3 00 00		    jp warm             ;Warm start 
03ec			 
03ec			exit_dos_err: 
03ec			;Print CBM DOS error message and return to CP/M 
03ec			; 
03ec 11 b3 05		    ld de,disk_error    ;DE = address of "Disk error:" 
03ef 0e 09		    ld c,cwritestr      ;C = Output String 
03f1 cd 05 00		    call bdos           ;BDOS system call 
03f4			 
03f4 21 c0 ea		    ld hl,dos_msg       ;HL = address of last CBM DOS error message 
03f7			l03f7h: 
03f7 e5			    push hl             ;Save HL 
03f8 5e			    ld e,(hl)           ;E = char from CBM DOS error message 
03f9 0e 02		    ld c,cwrite         ;C = write char to console out 
03fb cd 05 00		    call bdos           ;BDOS system call 
03fe e1			    pop hl              ;Restore HL 
03ff			 
03ff 7e			    ld a,(hl)           ;A = char from CBM DOS error message 
0400 23			    inc hl              ;Increment to next char in the message 
0401 fe 0d		    cp cr               ;Is this char a carriage return? 
0403 20 f2		    jr nz,l03f7h        ;  No: loop to handle next char 
0405 c3 00 00		    jp warm             ;Warm start 
0408			 
0408			newline: 
0408			;Print a newline (CR+LF) 
0408			; 
0408 1e 0d		    ld e,cr             ;E = carriage return 
040a 0e 02		    ld c,cwrite         ;C = write char to console out 
040c cd 05 00		    call bdos           ;BDOS system call 
040f			 
040f 1e 0a		    ld e,lf             ;E = line feed 
0411 0e 02		    ld c,cwrite         ;C = write char to console out 
0413 c3 05 00		    jp bdos             ;Jump out to BDOS, it will return to caller 
0416			 
0416			menu: 
0416 .. 0d 0a		    db "CP/M <--> Pet DOS file transfer",cr,lf 
0437 .. 0d 0a		    db "----      --- --- ---- --------",cr,lf 
0458			 
0458 0a .. 0d 0a	    db lf,"1.  Copy sequential file to PET DOS",cr,lf 
047e 0a .. 0d 0a	    db lf,"2.  Copy sequential file from PET DOS",cr,lf 
04a6 0a .. 0d 0a	    db lf,"3.  Copy BASIC program from PET DOS",cr,lf 
04cc 0a .. 0d 0a	    db lf,"4.  As 2.  but insert line feeds",cr,lf 
04ef 0a ..		    db lf,"Which type of transfer (1 to 4) ? $" 
0513			ask_src_drive: 
0513 ..			    db "PET DOS source drive (A-P) ? $" 
0531			ask_src_file: 
0531 ..			    db "PET DOS source file ? $" 
0548			ask_dest_drv: 
0548 ..			    db "PET DOS destination drive (A-P) ? $" 
056b			ask_dest_file: 
056b ..			    db "PET DOS destn. file ? $" 
0582			bad_filename: 
0582 0d 0a ..		    db cr,lf,"Bad file name$" 
0592			bad_drive: 
0592 0d 0a ..		    db cr,lf,"Bad drive name$" 
05a3			bad_command: 
05a3 0d 0a .. 0d 0a ..	    db cr,lf,"Bad command",cr,lf,"$" 
05b3			disk_error: 
05b3 0d 0a .. 0d 0a ..	    db cr,lf,"Disk error :",cr,lf,"$" 
05c4			disk_full: 
05c4 0d 0a ..		    db cr,lf,"Disk or directory full$" 
05dd			complete: 
05dd 0d 0a ..		    db cr,lf,"Transfer complete$" 
05f1			not_found: 
05f1 0d 0a ..		    db cr,lf,"File not found$" 
0602			 
0602			basic4_cmds: 
0602			;CBM BASIC 4.0 commands ordered by token 
0602			;Last character of each command has bit 7 set 
0602			; 
0602 .. c4		    db "EN",0c4h        ;END 
0605 .. d2		    db "FO",0d2h        ;FOR 
0608 .. d4		    db "NEX",0d4h       ;NEXT 
060c .. c1		    db "DAT",0c1h       ;DATA 
0610 .. a3		    db "INPUT",0a3h     ;INPUT# 
0616 .. d4		    db "INPU",0d4h      ;INPUT 
061b .. cd		    db "DI",0cdh        ;DIM 
061e .. c4		    db "REA",0c4h       ;READ 
0622 .. d4		    db "LE",0d4h        ;LET 
0625 .. cf		    db "GOT",0cfh       ;GOTO 
0629 .. ce		    db "RU",0ceh        ;RUN 
062c .. c6		    db "I",0c6h         ;IF 
062e .. c5		    db "RESTOR",0c5h    ;RESTORE 
0635 .. c2		    db "GOSU",0c2h      ;GOSUB 
063a .. ce		    db "RETUR",0ceh     ;RETURN 
0640 .. cd		    db "RE",0cdh        ;REM 
0643 .. d0		    db "STO",0d0h       ;STOP 
0647 .. ce		    db "O",0ceh         ;ON 
0649 .. d4		    db "WAI",0d4h       ;WAIT 
064d .. c4		    db "LOA",0c4h       ;LOAD 
0651 .. c5		    db "SAV",0c5h       ;SAVE 
0655 .. d9		    db "VERIF",0d9h     ;VERIFY 
065b .. c6		    db "DE",0c6h        ;DEF 
065e .. c5		    db "POK",0c5h       ;POKE 
0662 .. a3		    db "PRINT",0a3h     ;PRINT# 
0668 .. d4		    db "PRIN",0d4h      ;PRINT 
066d .. d4		    db "CON",0d4h       ;CONT 
0671 .. d4		    db "LIS",0d4h       ;LIST 
0675 .. d2		    db "CL",0d2h        ;CLR 
0678 .. c4		    db "CM",0c4h        ;CMD 
067b .. d3		    db "SY",0d3h        ;SYS 
067e .. ce		    db "OPE",0ceh       ;OPEN 
0682 .. c5		    db "CLOS",0c5h      ;CLOSE 
0687 .. d4		    db "GE",0d4h        ;GET 
068a .. d7		    db "NE",0d7h        ;NEW 
068d .. a8		    db "TAB",0a8h       ;TAB( 
0691 .. cf		    db "T",0cfh         ;TO 
0693 .. ce		    db "F",0ceh         ;FN 
0695 .. a8		    db "SPC",0a8h       ;SPC( 
0699 .. ce		    db "THE",0ceh       ;THEN 
069d .. d4		    db "NO",0d4h        ;NOT 
06a0 .. d0		    db "STE",0d0h       ;STEP 
06a4 ab			    db 0abh             ;+ 
06a5 ad			    db 0adh             ;- 
06a6 aa			    db 0aah             ;* 
06a7 af			    db 0afh             ;/ 
06a8 de			    db 0deh             ;^ 
06a9 .. c4		    db "AN",0c4h        ;AND 
06ac .. d2		    db "O",0d2h         ;OR 
06ae be			    db 0beh             ;> 
06af bd			    db 0bdh             ;= 
06b0 bc			    db 0bch             ;< 
06b1 .. ce		    db "SG",0ceh        ;SGN 
06b4 .. d4		    db "IN",0d4h        ;INT 
06b7 .. d3		    db "AB",0d3h        ;ABS 
06ba .. d2		    db "US",0d2h        ;USR 
06bd .. c5		    db "FR",0c5h        ;FRE 
06c0 .. d3		    db "PO",0d3h        ;POS 
06c3 .. d2		    db "SQ",0d2h        ;SQR 
06c6 .. c4		    db "RN",0c4h        ;RND 
06c9 .. c7		    db "LO",0c7h        ;LOG 
06cc .. d0		    db "EX",0d0h        ;EXP 
06cf .. d3		    db "CO",0d3h        ;COS 
06d2 .. ce		    db "SI",0ceh        ;SIN 
06d5 .. ce		    db "TA",0ceh        ;TAN 
06d8 .. ce		    db "AT",0ceh        ;ATN 
06db .. cb		    db "PEE",0cbh       ;PEEK 
06df .. ce		    db "LE",0ceh        ;LEN 
06e2 .. a4		    db "STR",0a4h       ;STR$ 
06e6 .. cc		    db "VA",0cch        ;VAL 
06e9 .. c3		    db "AS",0c3h        ;ASC 
06ec .. a4		    db "CHR",0a4h       ;CHR$ 
06f0 .. a4		    db "LEFT",0a4h      ;LEFT$ 
06f5 .. a4		    db "RIGHT",0a4h     ;RIGHT$ 
06fb .. a4		    db "MID",0a4h       ;MID$ 
06ff .. cf		    db "G",0cfh         ;GO 
0701 .. d4		    db "CONCA",0d4h     ;CONCAT 
0707 .. ce		    db "DOPE",0ceh      ;DOPEN 
070c .. c5		    db "DCLOS",0c5h     ;DCLOSE 
0712 .. c4		    db "RECOR",0c4h     ;RECORD 
0718 .. d2		    db "HEADE",0d2h     ;HEADER 
071e .. d4		    db "COLLEC",0d4h    ;COLLECT 
0725 .. d0		    db "BACKU",0d0h     ;BACKUP 
072b .. d9		    db "COP",0d9h       ;COPY 
072f .. c4		    db "APPEN",0c4h     ;APPEND 
0735 .. c5		    db "DSAV",0c5h      ;DSAVE 
073a .. c4		    db "DLOA",0c4h      ;DLOAD 
073f .. c7		    db "CATALO",0c7h    ;CATALOG 
0746 .. c5		    db "RENAM",0c5h     ;RENAME 
074c .. c8		    db "SCRATC",0c8h    ;SCRATCH 
0753 .. d9		    db "DIRECTOR",0d9h  ;DIRECTORY 
075c ff			    db 0ffh             ;End of table 
075d			 
075d			buffer: 
075d			;Buffer area used with the BDOS system call CREADSTR (0ah): 
075d			; 
075d			;  - buffer+0 is the total number of bytes available in the buffer 
075d			;    area.  The default value (2ah) is invalid.  Our code will load 
075d			;    it with 50h (80 bytes) before calling CREADSTR. 
075d			; 
075d			;  - buffer+1 is the number of valid data bytes in the buffer.  It 
075d			;    will be set by CREADSTR. 
075d			; 
075d			;  - buffer+2 is the start of the buffer data. 
075d			; 
075d 2a a0 3c 19 34 d1 f1 e6 7f f5 87 fa 92 2f 2a	    db 2ah,0a0h,3ch,19h,34h,0d1h,0f1h,0e6h,7fh,0f5h,87h,0fah,92h,2fh,2ah 
076c 8e 3c 7e b7 ca 81 2f f1 c5 47 04 2b 05 ca 6c 2f	    db 8eh,3ch,7eh,0b7h,0cah,81h,2fh,0f1h,0c5h,47h,04h,2bh,05h,0cah,6ch,2fh 
077c 7e d5 2f 5f 16 ff 19 d1 c3 5d 2f 7e b7 ca 8f 2f	    db 7eh,0d5h,2fh,5fh,16h,0ffh,19h,0d1h,0c3h,5dh,2fh,7eh,0b7h,0cah,8fh,2fh 
078c 3d 47 2b 7e 04 05 ca 8f 2f cd 21 31 05 c3 73 2f	    db 3dh,47h,2bh,7eh,04h,05h,0cah,8fh,2fh,0cdh,21h,31h,05h,0c3h,73h,2fh 
079c f1 2b 3c 3d ca 8c 2f 2b c3 84 2f 7e e1 c9 c1 e1	    db 0f1h,2bh,3ch,3dh,0cah,8ch,2fh,2bh,0c3h,84h,2fh,7eh,0e1h,0c9h,0c1h,0e1h 
07ac c9 3e 2e cd 21 31 cd 21 31 f1 e6 3f c5 2a 9b 3c	    db 0c9h,3eh,2eh,0cdh,21h,31h,0cdh,21h,31h,0f1h,0e6h,3fh,0c5h,2ah,9bh,3ch 
07bc 4f 06 00 09 44 cd b6 17 45 cd b6 17 c1 e1 1b 1a	    db 4fh,06h,00h,09h,44h,0cdh,0b6h,17h,45h,0cdh,0b6h,17h,0c1h,0e1h,1bh,1ah 
07cc c9 e5 cd 54 0b e1 c4 cb 2f f5 11 16 3b 1a 3c 4f	    db 0c9h,0e5h,0cdh,54h,0bh,0e1h,0c4h,0cbh,2fh,0f5h,11h,16h,3bh,1ah,3ch,4fh 
07dc 1a 77 13		    db 1ah,77h,13h 
07df			 
07df			src_drive: 
07df 2b			    db 2bh      ;CP/M source drive number (0=A:, 1=B:, ...) 
07e0			cbm_device: 
07e0 0d			    db 0dh      ;IEEE-488 primary address of CBM drive 
07e1			cbm_file: 
07e1 c2			    db 0c2h     ;File number on CBM drive 
07e2			insert_lf: 
07e2 c1			    db 0c1h     ;Insert linefeeds flag (0=off, 1=on) 
# End of file xfer.asm
07e3
