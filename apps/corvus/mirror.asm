; ------ CORVUS "MIRROR" UTILITY PROGRAM ------
;		 VERSION 1.33S/TT
;	    ( S100/TRS80 II VERSION )
;		     BY BRK
;
; THIS PROGRAM PROVIDES THE BASIC FUNCTIONS FOR THE
; CORVUS "MIRROR" DISC BACKUP SYSTEM.  IT WILL ONLY
; WORK ON SYSTEMS WITH CONTROLLER CODE VERSION > 0.
;
;
; =============================================================
; Modified for SoftBox by KRF  --  28 MAR 83
; =============================================================
;
;
;
;$I CRVSYS.S			; SYSTEM EQUATES
;	----	S100/TRS80 I/O PORT ADDRESSES & MASKS	----
;
STAT	EQU	16h	; STATUS I/O PORT
DATA	EQU	18h	; DATA I/O PORT
DRDY	EQU	10h	; MASK FOR DRIVE READY BIT
DRDYST	EQU	10h	; IF BIT 0 = 1 THEN DRIVE READY
DIFAC	EQU	20h	; MASK FOR DRIVE ACTIVE BIT
HTD	EQU	20h	; IF BIT 1 SET THEN HOST-TO-DRIVE STATUS
DTH	EQU	0	; IF BIT 1 = 0 THEN DRIVE-TO-HOST
;
;
;
;$I MIRROR.BDY			; MAIN BODY OF MIRROR CODE
;
;
; ---- CORVUS DISC EQUATES ----
;
VERCOM	EQU	0	; READ VERSION # AND # OF DRIVES COMMAND
;
BKUCOM	EQU	8	; MIRROR BACKUP COMMAND
RESCOM	EQU	9	; MIRROR RESTORE COMMAND
IDCOM	EQU	10	; MIRROR IDENT./VERIFY COMMAND
NSTAT	EQU	10H	; REV B STATUS COMMAND
RDCOM	EQU	2	; REV B READ COMMAND
;
SSIZE	EQU	512	; SECTOR SIZE
;
;
; ---- CP/M EQUATES -----
;
BDOS	EQU	05	; BDOS ENTRY POINT
CHIN	EQU	1	; BDOS COMMAND FOR CONSOLE INPUT
CHOUT	EQU	2	; BDOS COMMAND FOR CONSOLE OUTPUT
LST	EQU	9	; BDOS COMMAND FOR WRITE LIST
RDBUF	EQU	10	; BDOS COMMAND TO READ BUFFER
;
CR	EQU	0DH	; CARRIAGE RETURN
LF	EQU	0AH	; LINE FEED
;
	ORG 100H	; STANDARD CP/M TPA ORIGIN
;
START:	LXI	H,0
	DAD	SP	; GET STACK POINTER IN (H,L)
	SHLD	SBUF	; SAVE IT
;   -- SETUP DIRECT CONSOLE I/O JUMPS ---
	LHLD	1	; GET ADDRESS OF WARM BOOT (BIOS+3)
	LXI	D,3
	DAD	D	; COMPUTE ADDRESS OF CONST
	SHLD	CONST+1	; PATCH IN JUMP
	DAD	D
	SHLD	CONIN+1
	DAD	D
	SHLD	CONOUT+1
	JMP	SIGNON	; SIGN ON AND START PROGRAM
;
CONST:	JMP	0	; JUMP TO BIOS ROUTINES
CONIN:	JMP	0
CONOUT:	JMP	0
;
SIGNON:	LXI	SP,STACK	;SETUP LOCAL STACK
	LXI	D,SMSG		;POINT TO MESSAGE
	CALL	PTMSG		; PRINT SIGN ON MESSAGE
Q1:	LXI	D,MSG2
MN0:	CALL	PTMSG		; LIST TASK MENU
MN1:	LXI	SP,STACK	; RESET STACK
	LXI	D,MSG3
	CALL	PTMSG		; ASK FOR CHOICE
MN2:	CALL	CONNC		; GET THE TASK
	MOV	C,A		; MAY CONVERT ECHO TO UPPER CASE
	LXI	H,TSKTAB	; POINT TO TASK TABLE
	MVI	B,(TSKTBE-TSKTAB)/3  ; # TASKS IN TABLE
	CALL	STAB		; LOOK FOR COMMAND IN TABLE
	JC	MN2		; DIDN'T FIND IT, SO TRY AGAIN
	PUSH	D		; PUT COMMAND ADDRESS ON STACK
	CALL	COUT		; ECHO COMMAND
	LXI	D,CRLF
	JMP	PTMSG		; CRLF AND VECTOR TO COMMAND
;
; --- TASK TABLE ---
;
TSKTAB:	EQU	$
	DB	'L'
	DW	Q1
	DB	'H'
	DW	HELP
	DB	'B'	; COMMAND IDENTIFIER
	DW	BACKUP	; ROUTINE ADDRESS
	DB	'V'
	DW	VERIFY
	DB	'I'
	DW	IDENTIFY
	DB	'R'
	DW	RESTORE
	DB	'Q'
	DW	EXIT
TSKTBE	EQU	$	; END OF TASK TABLE
;
;
; --- LIST INSTRUCTIONS COMMAND ---
;
HELP:	LXI	D,MSGI
	JMP	MN0
;
; --- BACKUP COMMAND ROUTINE ---
;
BACKUP:	CALL	INITX	; SYNCHRONIZE AND READ VERSION #
	JC	MN1	; VERSION 0, SO EXIT
	MVI	A,BKUCOM	; GET BACKUP COMMAND
	STA	COMD	; SAVE IN BUFFER
	CALL	FILBUF	; FILL HEADER BUFFER WITH SPACES
	LXI	D,MSG5
	CALL	PTMSG	; ASK IF FULL DISC
	CALL	YES
	PUSH	PSW	; SAVE STATUS
	CALL	GTDRV	; GET DRIVE #
	CALL	SETMAX	; SET BUFFERS FOR FULL DISC SIZE
	POP	PSW	; RESTORE STATUS
	CNZ	GTSIZ	; IF NO, GET BLOCK LOCATION AND SIZE
	LXI	H,MSG14Z
	SHLD	MSGPTR	; SET "CONFIDENCE MESSAGE"
	LXI	H,SYSTM	; POINT TO SYSTEM TYPE
	LXI	D,BUF	; POINT TO BUFFER
	MVI	A,16	; SIZE OF HEADER PARTS
	STA	PRCTR
	MOV	C,A	; SIZE FOR COPY
	CALL	COPY	; COPY TO BUFFER
	XCHG
	SHLD	BFPTR	; SET BUFFER LOAD POINT
	LXI	D,MSGH
	CALL	PTMSG	; REQUEST HEADER DATA
	LXI	D,MSG9
	CALL	PTMSG	; ASK FOR DATE
	CALL	TXTIN	; GET AND SAVE IT
	LXI	D,MSG10
	CALL	PTMSG	; ASK FOR TIME
	CALL	TXTIN	; GET AND SAVE IT
	LXI	D,MSG11
	CALL	PTMSG	; ASK FOR NAME
	CALL	TXTIN
	MVI	A,80	; SET NEW LINE SIZE
	STA	PRCTR
	LXI	D,MSG12
	CALL	PTMSG	; ASK FOR COMMENT
	CALL	TXTIN	; GET AND SAVE IT
	LXI	D,MSG13
	CALL	PTMSG	; ASK FOR SPEED
	CALL	GTSPD	; GET IT
	STA	CK1	; SAVE IT
	LXI	D,MSG14
	CALL	PTMSG	; READY TO GO, JUST HIT CR
BK1:	CALL	CONNC	; GET CHAR.
	CPI	CR	; WAS IT A CR?
	JNZ	BK1	; NO, SO LOOP
;
	LXI	D,MSG14Y
	CALL	PTMSG	; NOTIFY OF DELAY
	MVI	B,40	; LONG DELAY (AT LEAST 7 SEC EVEN FOR 4MHZ Z80)
BDEL:	CALL	LDELAY	;    WAIT FOR RECORDER TO COME UP TO SPEED
	PUSH	B
	CALL	KTST	; ISSUE MESSAGE IF KEY IS HIT
	POP	B
	DCR	B
	JNZ	BDEL
	LXI	H,MSG15	; SET "CONFIDENCE MESSAGE"
	SHLD	MSGPTR
;
	LXI	H,COMD	; POINT TO START OF DATA TABLE
	LXI	B,SSIZE+8 ; SIZE OF TABLE
	CALL	WTBLK	; WRITE IT TO CONTROLLER
	LXI	D,MSG14X
	CALL	PTMSG	; "BACKUP STARTED"
	CALL	RECV	; GET DATA BACK
	CALL	BELL	; RING BELL TO INDICATE COMPLETION
	CALL	MIRCHK	; TEST FOR ERRORS AND LIST
	LDA	BUF	; GET ERROR BYTE
	ORA	A	; 0 ?
	JNZ	BK2	; IF NOT ZERO
	LXI	D,MSG16
	JMP	MN0	; NO ERRORS!!
BK2:	LXI	D,MSG17
	CALL	PTMSG	; NOTIFY OF ERRORS
	LDA	BUF+1	; GET # OF ERRORS
	CALL	DECBT	; GIVE HOW MANY
	LXI	D,MSG18	; END OF MESSAGE
	JMP	MN0
;
;
; --- RESTORE COMMAND PROCESSOR ---
;
RESTORE:
	CALL	INITX	; SYNCHRONIZE CONTROLLER AND READ VERSION #
	JC	MN1	; IF VERS=0
	MVI	A,RESCOM ; GET RESTORE COMMAND
	STA	COMD	; SET IT
	LXI	D,MSG40
	CALL	PTMSG	; ASK IF WHOLE DISC
	CALL	YES
	PUSH	PSW	; SAVE STATUS
	CALL	GTDRV	; GET DRIVE #
	CALL	SETMAX	; SET BUFFERS FOR FULL DISC SIZE
	POP	PSW	; GET STATUS BACK
	CNZ	GTSIZ	; IF NOT, GET SIZE AND LOCATION
	LXI	H,MSG42
	SHLD	MSGPTR	; SET "CONFIDENCE MESSAGE"
	LXI	D,MSG41
	CALL	PTMSG	; POSITION TAPE AND START
	LXI	H,COMD	; POINT TO START OF BUFFER
	MVI	B,7	; LENGTH OF BUFFER
	CALL	CKSUM	; CHECKSUM IT
	STA	CK1	; SAVE CHECKSUM
	LXI	B,8	; LENGTH OF BUFFER TO SEND
	CALL	WTBLK	; SEND IT TO CONTROLLER
	LDA	SRTN	; GET 'VERSION' RETURN CODE
	CPI	8FH	; IS THIS A 'REV B' DRIVE?
	JZ	RSTB	; YES, USE DIFFERENT ROUTINE
RST1:	CALL	VLST	; GET RETURN CODES AND ERRORS
	JNC	MN1	; IF NO FATAL ERRORS
	LXI	H,RTRBF	; POINT TO RETRY BUFFER
	MVI	B,3	; LENGTH OF BUFFER
	CALL	CKSUM	; DO CHECKSUM
	STA	CK2	; SAVE IT
	CALL	WTCMDS	; SEND COMMANDS TO CONTROLLER
	JMP	RST1	; DO A RETRY
;
RSTB:	CALL	RECV	; GET RETURN DATA
	CALL	BELL	; RING "BELL"
	CALL	MIRCHK	; TEST AND LIST ERRORS
	CMC
	JNC	RSTBEND	; RETURN IF FATAL ERROR
	LXI	H,RTBECOM ; POINT TO 'REV B' COMMAND
	MVI	B,3	; LENGTH OF COMMAND STRING
	CALL	CKSUM	; DO CHECKSUM
	STA	RTBECOM+3 ; SAVE IT AS LAST CHAR.
	CALL	VLST1	; GET ERROR STATUS AND LIST
	JNC	RSTBEND	; RETURN IF FATAL ERROR
	LXI	H,RTBCOM ; POINT TO 'REV B' RETRY COMMAND
	MVI	B,3
	CALL	CKSUM
	STA	RTBCOM+3 ; SAVE CHECKSUM
	CALL	WTCMDS	; SEND COMMAND STRING
	JMP	RSTB	; DO A RETRY
;
; THE FOLLOWING IS A FIX FOR 5MB DRIVES.  THE PROBLEM WAS THAT
; AFTER A RESTORE, THE DRIVE WOULD SAY READY, BUT WOULD RETURN
; A FATAL ILLEGAL SECTOR ADDRESS ERROR WHEN THE RESTORED DATA WAS
; ACCESSED. A READ OF SECTOR 0 IS DONE, AND FOR SOME REASON THIS
; FIXES THE PROBLEM.
;
RSTBEND: LDA	DRIVE	; PUT DRIVE # USED IN RESTORE OPERATION
	STA	RCOMD+1	; INTO READ SECTOR 0 COMMAND BLOCK
	LXI	H,RCOMD	; POINT TO COMMAND
	LXI	B,4	; LOAD BYTE COUNTER
	CALL	WTBLK	; WRITE COMMAND TO DRIVE
	CALL	DERROR	; RETREIVE ERROR CODE & OUTPUT MESSAGE
	CNC	RECV	; IF C NOT SET, THEN GET THE REQUESTED
	JMP	MN1	; SECTOR AND RETURN TO MAIN LOOP

; --- IDENTIFY COMMAND PROCESSOR ---
;
IDENTIFY:
	CALL	INITX	; SYNCHRONIZE CONTROLLER AND READ VERS. #
	JC	MN1	; IF VERS=0
	LXI	H,MSG34
	SHLD	MSGPTR	; SET "CONFIDENCE MESSAGE'
	LXI	D,MSG33
	CALL	PTMSG	; "POSITION TAPE ..."
	LXI	H,IDENT	; POINT TO COMMAND STRING
	CALL	WTCMDS	; SEND COMMANDS TO CONTROLLER
	LXI	H,BUF+1	; POINT TO BUFFER
	SHLD	BFPTR	; SAVE IT
	CALL	RECV	; READ DATA BACK
	CALL	MIRCHK	; TEST FOR ERRORS AND LIST
	JC	MN1	; IF ERROR, EXIT
;
	LHLD	RTLEN	; GET RETURN LENGTH
	LXI	D,515	; RETURN LENGTH IS BIGGER THAN THIS
	CALL	SUBDE
	JC	MN1	; IF ERROR, EXIT
	LXI	D,MSG35
	CALL	PTMSG	; HEADER
	CALL	GTCHR	; GET ID #
	CALL	DECBT	; OUTPUT IN DECIMAL
	LXI	D,MSG37
	CALL	PTMSG
	CALL	GTCHR
	MOV	L,A	; GET LENGTH IN (H,L)
	CALL	GTCHR
	MOV	H,A
	CALL	DECOUT	; OUTPUT IN DECIMAL
	LXI	D,MSG38
	CALL	PTMSG	; FINISH LENGTH DESCRIPTION
	MVI	A,16
	STA	PRCTR	; SET STRING LENGTH
	LXI	D,MSG39
	CALL	PRTL	; LIST SYSTEM
	LXI	D,MSG9+2
	CALL	PRTL	; LIST DATE
	LXI	D,MSG10+2
	CALL	PRTL	; LIST TIME
	LXI	D,MSG11+2
	CALL	PRTL	; LIST NAME
	MVI	A,64	; SET STRING LENGTH
	STA	PRCTR
	LXI	D,MSG12+2
	CALL	PRTL	; LIST COMMENT
	LXI	D,MSG12X+2
	CALL	PRTL	; REMAINDER OF COMMENT
	JMP	MN1
;
;
; --- VERIFY COMMAND PROCESSOR ---
;
VERIFY:
	CALL	INITX	; SYNCHRONIZE CONTROLLER AND READ VERS. #
	JC	MN1	; IF VERS. =0
	LXI	H,MSG20
	SHLD	MSGPTR	; SET "CONFIDENCE MESSAGE"
	LXI	D,MSG19
	CALL	PTMSG	; "START RECORDER ...."
	LXI	H,VERIF	; POINT TO COMMAND STRING
	CALL	WTCMDS	; SEND COMMANDS TO CONTROLLER
VF1:	CALL	VLST	; GET RETURN CODES AND LIST ERRORS
	JNC	MN1	; IF NO HARD ERRORS
	LXI	H,VERF1 ; POINT TO RETRY-VERIFY COMMAND STRING
	CALL	WTCMDS	; SEND COMMANDS TO CONTROLLER
	JMP	VF1	; LOOP TO KEEP TRYING
;
;
;
; ------ SUBROUTINES & DATA ------
;
; --- SEARCH TABLE FOR MATCH AND GET ASSOC. ADDRESS ---
;	(H,L) POINT TO TABLE TO SEARCH
;	(B)   HAS THE # OF TABLE ELEMENTS
;	(C)   HAS THE BYTE TO MATCH WITH
;
STAB:	MOV	A,M	; GET TABLE VALUE
	INX	H	; POINT TO START OF ADDRESS
	CMP	C	; IS THERE A MATCH?
	JNZ	STB1	; NO, SO CONTINUE
	MOV	E,M	; GET LOWER BYTE OF ADDRESS
	INX	H
	MOV	D,M	; ADDRESS IN (D,E)
	RET
STB1:	INX	H	; SKIP OVER ADDRESS
	INX	H
	DCR	B	; COUNT DOWN COMMANDS
	JNZ	STAB	; LOOP THRU TABLE
	STC		; NO MATCH, SO SET ERROR
	RET
;
; --- ERROR MESSAGE LISTER FOR RESTORE AND VERIFY ---
;	( SET CARRY ON RETURN ONLY IF WANT RE-TRY )
;
VLST:	CALL	RECV	; GET DATA BACK
	CALL	BELL	; RING "BELL"
	CALL	MIRCHK	; TEST FOR ERRORS AND LIST
	CMC
	RNC		; JUST RETURN IF ERROR
	LXI	H,ERCOM	; POINT TO ERROR LIST COMMAND
VLST1:	CALL	WTCMDS	; SEND COMMANDS TO CONTROLLER
	LXI	H,BUF	; SET BUFFER POINTER
	SHLD	BFPTR	; SET READ POINTER
	CALL	GETBLK	; 1.23 - READ IN DATA BLOCK
	LXI	D,MSG27
	CALL	PTMSG	; PRINT ERROR TABLE HEADER
	CALL	GTCHR	; GET # OF SOFT ERRORS IN (H,L)
	MOV	L,A
	CALL	GTCHR
	MOV	H,A
	CALL	DECOUT	; OUTPUT IN DECIMAL
	LXI	D,MSG28
	CALL	PTMSG	; "# OF DISC ERRORS"
	CALL	GTCHR	; THROW THIS AWAY
	CALL	GTCHR
	CALL	DECBT	; OUTPUT IN DECIMAL
	LXI	D,MSG30
	CALL	PTMSG	; " # BLOCKS NEEDING RETRY"
	CALL	GTCHR
	PUSH	PSW	; SAVE IT ALSO
	CALL	DECBT	; PRINT IT OUT
	POP	PSW
	ORA	A	; TEST IF ZERO
	JNZ	VL3	; IF NOT, MUST READ MORE DATA
	LXI	D,MSG31
	JMP	PTMSG	; "ALL DATA RECEIVED"
VL3:	LXI	D,MSG32
	CALL	PTMSG	; "RETRY   <CR>"
VL5:	CALL	CONNC
	CPI	CR	; IS IT A CR?
	JNZ	VL5	; NO, SO TRY AGAIN
	LXI	D,CRLF
	CALL	PTMSG
	STC		; NOTE ERROR FOR RETRY
	RET
;
; --- MIRROR ERROR CHECKER AND LISTER ---
;
MIRCHK:	LDA	BUF	; GET FIRST RTN CODE
	PUSH	PSW	; SAVE IT
	CALL	DERR2	; LIST IF DISC ERROR
	POP	PSW
	CPI	255	; TEST FOR MIRROR ERROR
	JNZ	MCK2
	LDA	BUF+1	; GET SECOND RETURN BYTE
	MOV	C,A	; SAVE FOR TEST
	LXI	H,ERRTAB ; POINT TO TABLE OF ERRORS
	MVI	B,(ERRTBE-ERRTAB)/3 ; SIZE OF TABLE
	CALL	STAB	; LOOK THRU TABLE
	JNC	MCK1	; IF MATCH, JUST LIST ERROR AND RET
	LXI	D,MSG26	; NO MATCH, SO LIST ERROR #
	CALL	PTMSG
	LDA	BUF+1
	CALL	DECBT	; PRINT ERROR # IN DECIMAL
	LXI	D,CRLF
MCK1:	CALL	PTMSG
	CALL	BELL	; RING BELL
	STC
	RET
MCK2:	CPI	80H	; GREATER THAN 7FH?
	CMC		; SET CARRY IF #>=80H
	CC	BELL	; RING BELL IF ERROR
	RET
;
; --- ERROR MESSAGE TABLE ---
;
ERRTAB:
	DB	1
	DW	EM1MSG
	DB	2
	DW	EM2MSG
	DB	3
	DW	EM3MSG
	DB	4
	DW	EM4MSG
	DB	5
	DW	EM5MSG
	DB	7
	DW	EM7MSG
	DB	134
	DW	EM134MSG
ERRTBE:	EQU	$
;
;
; --- PRINT MESSAGE AND LIST TEXT IN BUFFER ---
;
PRTL:	PUSH	D	; SAVE MESSAGE POINTER
	CALL	PTMSG	; PRINT MESSAGE
	LDA	PRCTR	; GET BUFFER SIZE
	MOV	B,A
PT1:	CALL	GTCHR	; GET BUFFER CHARACTER
	CALL	PRT	; PRINT IT OUT
	DCR	B	; COUNT DOWN
	JNZ	PT1	; LOOP UNTIL DONE
	LXI	D,CRLF
	CALL	PTMSG	; DO A CRLF
	POP	D	; GET POINTER BACK
	RET
;
;
GTCHR:	PUSH	H
	LHLD	BFPTR	; GET BUFFER POINTER
	MOV	A,M	; GET BYTE
	INX	H	; INCREMENT POINTER
	SHLD	BFPTR	; SAVE POINTER
	POP	H
	RET
;
;
KTST:	CALL	CONST	; TEST CONSOLE STATUS
	ORA	A
	RZ		; RETURN IF NO KEY HAS BEEN HIT
	CALL	CONIN	; OTHERWISE GET THE CHAR.
	PUSH	PSW	; SAVE CHAR.
	LHLD	MSGPTR	; GET POINTER TO MESSAGE
	XCHG
	CALL	PTMSG	; PRINT IT OUT
	POP	PSW	; GET CHAR. BACK
	RET
;
; --- READ IN BLOCK OF DATA FROM DISC ---
;
RDBLK:	CALL	WAITI	; 1.32 - USE WAITI ROUTINE TO GET BYTE
	MOV	M,A	; SAVE IT IN MEMORY
	INX	H
	DCX	B
	MOV	A,B
	ORA	C
	JNZ	RDBLK	; LOOP UNTIL DONE
	RET
;
; --- RECEIVE BLOCK INTO BUFFER ---
;
RECV:	LXI	H,BUF	; SET BUFFER LOCATION
; --- GET A BLOCK OF UNDETERMINED LENGTH BACK FROM DISC ---
;
GETBLK:	PUSH	H
	CALL	MTURN	; WAIT FOR BUSS TO TURN AROUND
	POP	H
	CALL	GTBLK	; 1.32 - USE GTBLK ROUTINE
	POP	H	; GET COUNT OFF STACK
	SHLD	RTLEN	; SAVE IT
	RET
;
; --- WRITE A BLOCK OF DATA TO THE DISC ---
;
WTCMDS:	LXI	B,4	; SET SIZE FOR MIRROR COMMANDS
;
WTBLK:	MOV	A,M	; PUT BYTE INTO ACC
	CALL	WAITO	; 1.32 - USE WAITO ROUTINE TO PUT BYTE
	INX	H
	DCX	B
	MOV	A,B
	ORA	C
	JNZ	WTBLK	; LOOP UNTIL DONE
	RET
;
DERROR:	CALL	MTURN	; TURN AROUND BUSS
DERR1:	CALL	WAITI	; WAIT FOR ERROR BYTE
DERR2:	MOV	B,A	; SAVE BYTE
	STA	R1	; SAVE IN BUFFER ALSO
	CPI	255	; TEST FOR MIRROR ERROR
	RZ		; RETURN FOR LATER LISTING
	ANI	80H	; LOOK FOR FATAL ERRORS
	RZ		; OK, SO RETURN
	PUSH	B	; SAVE ERROR
	LXI	D,MSGE	; ERROR, SO ISSUE MESSAGE
	CALL	PTMSG
	POP	PSW	; GET ERROR BYTE BACK IN ACC
	CALL	HEXOT	; OUTPUT IN HEX
	LXI	D,MSGE1
	CALL	PTMSG
	STC		; SET CARRY ON ERROR RETURN
	RET
;
;
MTURN:	CALL	KTST		; TEST FOR KEY DEPRESSED (1.33)
	IN	STAT		; DELAY TILL DATA STABLE
	ANI	DRDY OR DIFAC	; TEST STATUS
	CPI	DRDYST OR DTH	; IS DRIVE READY & DRIVE-TO-HOST
	JNZ	MTURN		; IF NOT THEN LOOP
;
	MVI	B,25		; SET DELAY COUNT
	CALL	DELAY		; FOR 6MHZ
;
	IN	STAT		; DELAY TILL DATA STABLE
	ANI	DRDY OR DIFAC	; TEST STATUS
	CPI	DRDYST OR DTH	; IS DRIVE READY & DRIVE-TO-HOST
	JNZ	MTURN		; IF NOT THEN LOOP
;
	MVI	B,25		; SET DELAY COUNT
	CALL	DELAY		; FOR 6MHZ
	RET
;
;
; --- LONG DELAY ROUTINE ---
;
LDELAY:	PUSH	B
	LXI	B,41665	; SET FOR 0.5 SEC (2 MHZ  8080A)
LDEL1:	DCX	B
	MOV	A,B
	ORA	C
	JNZ	LDEL1	; LOOP UNTIL DONE
	POP	B
	RET
;
; --- TEST DRIVE TYPE AND REV A CODE VERSION # ---
;
VCHK:	CALL	INIT	; 1.32 - USE INIT TO RESYNC CONTROLLER
	MVI	A,VERCOM ; REV A VERSION # TEST
	CALL	WAITO	; SEND IT
	CALL	MTURN	; WAIT FOR ACCEPTANCE
	CALL	WAITI	; GET ANSWER
	STA	SRTN
	MOV	B,A	; SAVE IT
	ANI	0F0H	; MASK OUT DRIVE # AND TEST VERSION #
	MOV	A,B	; GET CODE BACK
	RET
;
;
INITX:	CALL	VCHK	; INITIALIZE AND TEST VERS. #
	RNZ		; IF # > 0
	LXI	D,MSG4
	CALL	PTMSG	; ISSUE ERROR MESSAGE
	STC		; SET ERROR CONDITION
	RET
;
; --- SETUP MAXIMUM # OF 512 BYTE BLOCKS ---
;
SETMAX:	LDA	SRTN
	CPI	8FH		; TEST RETURN CODE
	CZ	BSTAT1		; IF REV B DRIVE
	CNZ	REVAFIX		; IF REV A DRIVE
;
	LHLD	STATBF+37	; GET LOWER PART OF MAX BLOCK ADD
	SHLD	MAXSC		; SET MAX
	LDA	STATBF+39	;  AND GET ITS UPPER BYTE
	STA	MAXSC+2
; --- SET BUFFERS FOR WHOLE DISC SAVE/ RESTORE ---
;
STMAX:	LHLD	MAXSC	; GET # 512 BLOCKS ON DISC
	SHLD	BLEN
	LXI	H,0	; GET STARTING DISC ADDRESS
	SHLD	BKSTRT
	RET
;
; --- SET REV A EQUIV. STATUS INFORMATION ---
;
REVAFIX: LDA	SRTN	; GET RETURN CODE
	CPI	8FH	; REV B DRIVE ?
	RZ		; YES, SO EXIT
	PUSH	PSW
	LXI	H,REVADTA ; POINT TO REV A DATA
	LXI	D,STATBF+33 ; SET DESTINATION
	MVI	C,7	; LENGTH OF TABLE TO MOVE
	CALL	COPY	; DO IT
	POP	PSW	; RESTORE RTN CODE
	RET
;
; --- READ REV B STATUS STRING ---
;
BSTAT:	CALL	GTDRV		; GET DRIVE #
BSTAT1:	LXI	H,CRLF
	SHLD	MSGPTR		; SET MESSAGE IN CASE KEY IS HIT
	MVI	A,NSTAT		; GET STATUS COMMAND
	CALL	WAITO
	LDA	DRIVE
	CALL	WAITO
;
	CALL	DERROR
	JC	MN1		; IF ERROR
	LXI	H,STATBF	; SET BUFFER ADDRESS
	LXI	B,128		; SET BLOCK LENGTH
	CALL	RDBLK		; GET DATA BLOCK
	LXI	H,STATBF+33	; POINT TO #SECTORS/TRACK
	XRA	A
	CMP	M		; IS VALUE 0 (BUG IN EARLY ROM)
	RNZ			; NO, SO RETURN
	MVI	M,20		; YES, SO FIX IT
	RET
;
;
; --- MESSAGE PRINT ROUTINE---
;
PTMSG:	MVI	C,LST	; CP/M WRITE LIST COMMAND
	CALL	BDOS	; EXECUTE BDOS COMMAND
	ORA	A	; INSURE CARRY IS CLEARED
	RET
;
; --- OUTPUT BYTE IN ACC IN HEX ---
;
HEXOT:	PUSH	PSW	; SAVE BYTE
	RRC		; SHIFT UPPER NIBBLE DOWN
	RRC
	RRC
	RRC
	CALL	HEXB	; OUTPUT UPPER NIBBLE IN HEX
	POP	PSW	; GET BYTE BACK
HEXB:	ANI	0FH	; MASK OFF UPPER NIBBLE
	ADI	'0'	; ADD ASCII BIAS
	CPI	'9'+1	; TEST IF NUMERIC
	JC	PRT	; YES, SO DO IT
	ADI	7	; NO, SO ADD BIAS FOR A-F
PRT:	MOV	C,A	; SETUP FOR OUTPUT
COUT:	PUSH	PSW
	PUSH	H	; BUFFERED CONSOLE OUTPUT
	PUSH	D
	PUSH	B
	MOV	E,C
	MVI	C,CHOUT	; BDOS CHAR. OUTPUT COMMAND
	CALL	BDOS
	POP	B
	POP	D
	POP	H
	POP	PSW
	RET
;
; --- OUTPUT (H,L) IN DECIMAL ---
;
DECOUT:	LXI	D,-10000	; SET TO SUBTRACT 10000
	MVI	B,'0'		; SET TO SUPRESS LEADING ZEROS
	CALL	DEC2		; OUTPUT FIRST CHAR.
	LXI	D,-1000		; SET TO SUBTRACT 1000
	CALL	DEC2		; OUTPUT SECOND CHAR.
DEC4:	LXI	D,-100		; SET TO SUBTRACT 100
	CALL	DEC2		; OUTPUT THIRD CHAR.
	LXI	D,-10		; SET TO SUBTRACT 10
	CALL	DEC2		; OUTPUT FORTH CHAR.
	MVI	B,0		; ALLOW LEADING ZERO
	LXI	D,-1		; SET TO SUBTRACT  1
DEC2:	MVI	C,'0'-1		; SET CHAR. COUNT
DEC3:	SHLD	DECBUF		; SAVE REMAINDER
	INR	C		; INC. ASCII CHAR. COUNTER
	DAD	D		; DO SUBTRACTION
	JC	DEC3		; LOOP UNTIL UNDERFLOW
	LHLD	DECBUF		; GET LAST REMAINDER
	MOV	A,C		; GET CHAR. COUNTER
	CMP	B		; TEST FOR ZERO SUPPRESS
	JZ	SPACE		; ISSUE SPACE IF ZERO SUPPRESS IS ON
	MVI	B,0		; CLEAR ZERO SUPPRESS FLAG
	JMP	COUT		; OUTPUT CHAR.
SPACE:	MVI	C,' '		; SEND ASCII SPACE TO CONSOLE
	JMP	COUT
;
; -- OUTPUT BYTE IN DECIMAL --
;
DECBT:	PUSH	H
	PUSH	D
	PUSH	B
	MOV	L,A	; SAVE BYTE IN (H,L)
	MVI	H,0
	MVI	B,'0'	; SET TO SUPRESS LEADING ZEROS
	CALL	DEC4
	POP	B
	POP	D
	POP	H
	RET
;
;
; -- TWO BYTE DECIMAL INPUT ROUTINE --
;
INDEC:	LXI	H,0	; CLEAR CONVERSION REGISTER
IN1:	PUSH	H
	CALL	CONNC	; GET CHARACTER
	POP	H
	CPI	' '	; IS IT A SPACE?
	JZ	IN1	; IGNORE IT
	CPI	CR	; IS IT A CR?
	RZ		; YES, SO RETURN
	CALL	COUT	; ECHO CHAR.
	SUI	'0'	; REMOVE ASCII BIAS
	RC		; RETURN IF ERROR
	CPI	10	; TEST IF TOO BIG
	CMC
	RC		; RETURN IF ERROR
	MOV	E,L	; GET COPY OF (H,L) IN (D,E)
	MOV	D,H
	DAD	H	; MULTIPLY BY 5
	DAD	H
	DAD	D
	DAD	H	; NOW  10 X STARTING VALUE
	MOV	E,A
	MVI	D,0
	DAD	D	; ADD IN NEW UNITS DIGIT
	PUSH	H	; SAVE IT
	XCHG
	LHLD	MAXSC	; GET MAX. DISC ADDRESS
	XCHG
	CALL	SUBDE
	POP	H
	CMC
	JNC	IN1	; IF OK, GET MORE DIGITS
	RET		; RETURN IF ERROR
;
; -- YES FUNCTION --
;
YES:	CALL	CONNC	; GET CONSOLE CHAR.
	CPI	'Y'	; IS IT A  Y?
	JZ	YES1
	CPI	'N'	; IS IT A  N?
	JNZ	YES	; IF NEITHER, KEEP TRYING
	INR	A	; SET  N  STATUS
YES1:	PUSH	PSW	; SAVE FLAGS
	CALL	COUT	; OUTPUT TO CONSOLE
	POP	PSW	; RESTORE FLAGS
	RET
CONNC:	CALL	CONIN	; GET CHAR. FROM CONSOLE
	MOV	C,A	; SAVE FOR ECHO
	CPI	60H	; IS IT LOWER CASE?
	JC	CON1	; NO, SO CONTINUE
	ANI	5FH	; YES, SO MASK TO UPPER CASE
CON1:	CPI	'C'-40H	; IS IT A CONTROL-C?
	RNZ		; NO, SO RETURN
CTC:	LXI	D,CMSG	; POINT TO CONTROL-C MESSAGE
EXMG:	CALL	PTMSG		; ISSUE MESSAGE
EXIT:	LXI	D,CRLF
	CALL	PTMSG		; ISSUE A CRLF
	LHLD	SBUF		; GET OLD STACK POINTER
	SPHL			; SET STACK
	RET			; BACK TO CP/M
;
;
; --- ASK FOR AND GET DRIVE # ---
;
GTDRV:	LXI	D,DMSG
	CALL	PTMSG	; ASK FOR DRIVE #
GTDRV1:	CALL	CONNC	; GET CONSOLE CHAR.
	CPI	'1'
	JC	GTDRV1	; IF INVALID, TRY AGAIN
	CPI	'4'+1
	JNC	GTDRV1
	SUI	'0'	; REMOVE ASCII BIAS
	STA	DRIVE	; SAVE IT
	STA	RTBCOM+1 ; SAVE FOR 'REV B' RESTORE COMMANDS
	STA	RTBECOM+1
	JMP	COUT	; ECHO IT AND RETURN
;
; --- ASK FOR AND GET DISC BLOCK LOCATION AND SIZE ---
;
GTSIZ:	LXI 	D,MSG6
	CALL	PTMSG	; ASK FOR STARTING BLOCK #
	CALL	INDEC	; GET IT
	JC	GTSIZ	; IF ERROR, TRY AGAIN
	SHLD	BKSTRT	; SAVE IT IN BUFFER
GTSZ1:	LXI	D,MSG7
	CALL	PTMSG	; ASK FOR LENGTH
	CALL	INDEC	; GET IT
	JC	GTSZ1	; IF ERROR, TRY AGAIN
	MOV	A,H
	ORA	L	; IS IT ZERO?
	JZ	GTSZ1	; YES, SO TRY AGAIN
	SHLD	BLEN	; SAVE IT
	XCHG
	LHLD	BKSTRT	; GET STARTING LOC. BACK
	DAD	D	; FIND ENDING LOC.
	XCHG
	LHLD	MAXSC	; GET MAX BLOCK ADDRESS
	CALL	SUBDE	; CHECK IF TOO BIG
	RNC
	LXI	D,BMSG
	CALL	PTMSG	; PRINT ERROR MESSAGE
	JMP	GTSIZ	; TRY AGAIN
;
;
; --- GET SPEED OF BACKUP (FAST OR NORMAL) ---
;
GTSPD:	CALL	CONNC	; GET CHAR.
	CPI	'F'	; WAS IF FAST?
	MVI	B,0	; # FOR FAST
	JZ	GTS1	; YES
	CPI	'N'	; WAS IT NORMAL?
	MVI	B,1	; # FOR NORMAL
	JNZ	GTSPD	; IF NO MATCH, TRY AGAIN
GTS1:	CALL	COUT	; ECHO KEY HIT
	MOV	A,B	; GET #
	RET
;
; --- BLOCK CHECKSUM ROUTINE ---
;
CKSUM:	PUSH	H	; SAVE POINTER
	XRA	A	; INITIALIZE
	MOV	C,M	; GET BYTE
	ADD	C	; DO CHECKSUM
	INX	H	; POINT TO NEXT LOC.
	DCR	B	; COUNT DOWN
	JNZ	CKSUM+2	; LOOP UNTIL DONE
	CMA		; FIND NEGATIVE AND RETURN
	INR	A
	POP	H
	RET
;
; --- SUBTRACT: (H,L)=(H,L)-(D,E) ---
;
SUBDE:	MOV	A,L
	SUB	E
	MOV	L,A
	MOV	A,H
	SBB	D
	MOV	H,A
	RET
;
;
; --- INPUT TEXT LINE AND SAVE IN DISC BUFFER ---
;
TXTIN:	LDA	PRCTR	; GET BUFFER SIZE
	LXI	D,TXBUF	; POINT TO TEXT BUFFER
	STAX	D	; SAVE MAX SIZE ( FOR CP/M FUNCTION)
	MVI	C,RDBUF	; GET CP/M BUFFER READ COMMAND
	CALL	BDOS	; INPUT TEXT STREAM
	LHLD	BFPTR	; GET BUFFER POINTER
	PUSH	H	; SAVE IT
	LDA	PRCTR	; GET MAX TEXT BLOCK SIZE
	MOV	E,A	; GET INTO (D,E)
	MVI	D,0
	DAD	D	; COMPUTE NEW POINTER
	SHLD	BFPTR	; SAVE IT
	POP	D	; GET BACK DESTINATION ADDRESS
	LXI	H,TXBUF+1 ; POINT TO BUFFER COUNTER
	MOV	A,M	; GET IT
	ORA	A	; IS IT ZERO?
	RZ		; YES, SO FINISH
	MOV	C,M	; NO, SO GET AS COUNTER
	INX	H	; POINT TO START OF TEXT
COPY:	MOV	A,M	; GET SOURCE BYTE
	STAX	D	; SAVE COPY AT DESTINATION
	INX	H
	INX	D
	DCR	C	; COUNT DOWN # TO COPY
	JNZ	COPY	; LOOP UNTIL DONE
	RET
;
; --- BUFFER FILL ROUTINE ---
;
FILBUF:	LXI	B,SSIZE+4 ; SET SIZE
	LXI	H,BUF	; LOCATION OF BUFFER
FILL:	MVI	M,' '	; FILL WITH SPACES
	INX	H
	DCX	B
	MOV	A,B
	ORA	C
	JNZ	FILL	; LOOP UNTIL DONE
	RET
;
; --- RING BELL ON TERMINAL (CONTROL-G) ---
;
BELL:	PUSH	B
	MVI	C,'G'-40H ; GET CONTROL-G
	CALL	COUT
	POP	B
	RET
;
;
;$I CRV.IO			; CORVUS BASIC IO ROUTINES
;FILEID: CRV.IO
;

TURN:				; WAIT FOR DRIVE-TO-HOST STATUS AND
	IN	STAT		; DELAY TILL DATA STABLE
	ANI	DRDY OR DIFAC	; TEST STATUS
	CPI	DRDYST OR DTH	; IS DRIVE READY & DRIVE-TO-HOST
	JNZ	TURN		; IF NOT THEN LOOP
	MVI	B,6		; SET DELAY COUNT
	CALL	DELAY		; GOOD AT 4MHZ ALSO
	RET			;
;
DELAY:	DCR	B
	JNZ	DELAY
	RET
;
WAITI:	IN	STAT	; READ STATUS PORT
	ANI	DRDY OR DIFAC	; LOOK AT STATUS
	CPI	DRDYST OR DTH	; IS DRIVE READY & DRIVE-TO-HOST
	JNZ	WAITI	; LOOP UNTIL READY
	IN	DATA	; READ BYTE FROM DISC
	RET
;
WAITO:	PUSH	PSW	; SAVE COMMAND
	IN	STAT	; READ STATUS PORT
	ANI	DRDY OR DIFAC	; LOOK AT STATUS
	CPI	DRDYST OR HTD	; IS DRIVE READY & HOST-TO-DRIVE
	JNZ	WAITO+1	; LOOP UNTIL READY
	POP	PSW
	OUT	DATA	; WRITE BYTE TO DISC
	RET

;
;$I CRVINIT.IO			; INITIALIZE CONTROLLER ROUTINE
;FILEID: CRVINIT.IO
;
;
; --- INITIALIZE CONTROLLER ----
;
INIT:	MVI	A,0FFH	; GET AN INVALID COMMAND
	OUT	DATA	; SEND IT TO CONTROLLER
	MVI	B,150	; SET FOR LONG DELAY
	CALL	DELAY
	IN	STAT
	ANI	DRDY OR DIFAC	; LOOK AT DRIVE ACTIVE BIT
	CPI	DRDYST OR DTH	; IS STATUS = READY & DRIVE-TO-HOST
	JNZ	INIT	; LOOP UNTIL DRIVE-TO-HOST
	CALL	WAITI	; GET ERROR CODE
	CPI	8FH	; CHECK RETURN CODE
	JNZ	INIT	; IF NOT RIGHT, TRY AGAIN
	RET
;
;$I GTBLK.IO			;
;FILEID: GTBLK.IO
;
; --- GET A BLOCK OF UNDETERMINED LENGTH BACK FROM DISC ---
;
GTBLK:
	LXI	D,0	; INIT COUNT
GTB1:	IN	STAT	; GET STATUS
	MOV	C,A	; SAVE IT
	ANI	DRDY	; TEST READY BIT
	CPI	DRDYST	; IS DRIVE READY
	JNZ	GTB1	; LOOP UNTIL READY
	MOV	A,C
	ANI	DIFAC	; TEST BUSS DIRECTION
	CPI	HTD	; IS IT HOST-TO-DRIVE
	JZ	GTB2	; IF  SO THEN NO MORE BYTES
	CALL	WAITI	; GET DATA BYTE
	MOV	M,A	; SAVE IT
	INX	H
	INX	D
	JMP	GTB1
GTB2:	XCHG		; GET COUNT IN (H,L)
	XTHL            ; SAVE IT
	PCHL            ; RETURN

;
;
; ---- MESSAGES ----
;
SMSG:	DB CR,LF,' --- CORVUS MIRROR UTILITY ---'
	DB CR,LF,' VERSION 1.33  /   FOR SOFTBOX',CR,LF,'$'
;
;$I MIRROR.DAT			;
;
MSG2:	DB CR,LF,' --- MIRROR MENU ---',CR,LF
	DB CR,LF,' L:  LIST THIS MENU'
	DB CR,LF,' H:  LIST HELP DATA'
	DB CR,LF,' B:  BACKUP '
	DB CR,LF,' V:  VERIFY '
	DB CR,LF,' I:  IDENTIFY'
	DB CR,LF,' R:  RESTORE '
	DB CR,LF,' Q:  QUIT '
	DB CR,LF,'$'
;
MSG3:	DB CR,LF,' TASK (L TO LIST) : $'
;
MSG4:	DB CR,LF,07
	DB ' ->> THIS FEATURE IS NOT AVAILABLE UNDER VERS. 0 CONTROLLER CODE'
CRLF:	DB CR,LF,'$'
;
;
MSGE:	DB CR,LF,CR,LF,07,' ** DISC R/W ERROR # $'
;
MSGE1:	DB 'H **',CR,LF,'$'
;
DMSG:	DB CR,LF,' CORVUS DRIVE #  (1-4) ? $'
;
CMSG:	DB '^C',CR,LF,'$'
;
BMSG:	DB CR,LF,07,' -- THIS WOULD EXCEED DISC SIZE --',CR,LF,'$'
;
MSG5:	DB CR,LF,' BACKUP ENTIRE CORVUS DISC (Y/N) ? $'
;
MSG6:	DB CR,LF,' STARTING DISC BLOCK # ? $'
;
MSG7:	DB CR,LF,'      NUMBER OF BLOCKS ? $'
;
MSG8:	DB CR,LF,07,' ** THIS WOULD EXCEED DISC SIZE **',CR,LF,'$'
;
MSGH:	DB CR,LF
	DB CR,LF,' --- ENTER TAPE FILE HEADER INFORMATION ---',CR,LF
	DB '$'
MSG9:	DB CR,LF,'    DATE : $'
MSG10:	DB CR,LF,'    TIME : $'
MSG11:	DB CR,LF,'    NAME : $'
;
MSG12:	DB CR,LF,' COMMENT : $'
;
MSG12X:	DB CR,LF,'           $'
;
MSG13:	DB CR,LF,' NORMAL OR FAST FORMAT (N/F) ? $'
;
MSG14:	DB CR,LF,' STARTUP RECORDER AND PRESS RETURN $'
;
MSG14X:	DB CR,LF,' >> BACKUP HAS STARTED <<',CR,LF,'$'
;
MSG14Y:	DB CR,LF
;
MSG14Z:	DB CR,LF,' WAITING FOR RECORDER TO SPEED UP ...',CR,LF,'$'
;
MSG15:	DB CR,LF,' BACKUP IN PROGRESS ...',CR,LF,'$'
;
MSG16:	DB CR,LF,' BACKUP DONE -- NO DISC ERRORS',CR,LF,'$'
;
MSG17:	DB CR,LF,' THERE WERE $'
;
MSG18:	DB ' DISC READ ERRORS DURING BACKUP $',CR,LF
;
MSG19:	DB CR,LF,' START RECORDER AT BEGINNING OF IMAGE',CR,LF
;
MSG20:	DB CR,LF,' VERIFY IN PROGRESS ...',CR,LF,'$'
;
EM1MSG:	DB CR,LF,' IMAGE ID NOT EQUAL TO 1',CR,LF,'$'
;
EM2MSG:	DB CR,LF,' ILLEGAL RESTORE COMMAND',CR,LF,'$'
EM3MSG:	DB CR,LF,'ILLEGAL RETRY COMMAND',CR,LF,'$'
;
EM4MSG:	DB CR,LF,' IMAGE SIZE MISMATCH',CR,LF,'$'
;
EM5MSG:	DB CR,LF,' ILLEGAL COMMAND',CR,LF,'$'
;
EM7MSG:	DB CR,LF,' TIMEOUT - NO IMAGE FOUND',CR,LF,'$'
;
EM134MSG: DB CR,LF,' TAPE DROPOUT DURING PLAYBACK',CR,LF,'$'
;
MSG26:	DB CR,LF,' MIRROR ERROR # $'
;
MSG27:	DB CR,LF,' --- ERROR STATISTICS ---',CR,LF,CR,LF
	DB ' # SOFT ERRORS :$'
;
MSG28:	DB CR,LF,' # DISC ERRORS :  $'
;
MSG30:	DB CR,LF,' # OF BLOCKS NEEDING RETRYS :  $'
;
MSG31:	DB CR,LF,CR,LF,' ALL DATA RECEIVED ',CR,LF,'$'
;
MSG32:	DB CR,LF,07,' -- RETRY NEEDED --'
	DB CR,LF,' START RECORDER AT BEGINNING OF IMAGE -- PRESS RETURN $'
;
MSG33:	DB CR,LF,' POSITION TAPE AND START PLAYBACK ',CR,LF
;
MSG34:	DB CR,LF,' SEARCHING FOR IMAGE HEADER ...',CR,LF,'$'
;
MSG35:	DB CR,LF,' --- IMAGE RECORDED FROM CORVUS DRIVE ---',CR,LF
;
	DB CR,LF,' IMAGE ID : $'
;
MSG37:	DB CR,LF,' IMAGE LENGTH : $'
;
MSG38:	DB ' BLOCKS ',CR,LF,'$'
;
MSG39:	DB CR,LF,'  SYSTEM : $'
;
MSG40:	DB CR,LF,' RESTORE ENTIRE DISC (Y/N) ? $'
;
MSG41:	DB CR,LF
	DB CR,LF,' POSITION TAPE AND START PLAYBACK ',CR,LF
;
MSG42:	DB CR,LF,' RESTORE IN PROGRESS ...',CR,LF,'$'
;
SYSTM:	DB 'CP/M            '
;
;
;
;
;
MSGI:	DB CR,LF
	DB CR,LF,'     THIS PROGRAM PROVIDES THE BASIC CONTROL FUNCTIONS'
	DB CR,LF,' FOR THE CORVUS "MIRROR" DISC BACKUP SYSTEM.  IT WILL'
	DB CR,LF,' ONLY WORK ON SYSTEMS WITH CONTROLLER CODE VERSION > 0.'
	DB CR,LF,' FUNCTIONS PROVIDED ARE:',CR,LF
	DB CR,LF,'  B: BACKUP'
	DB CR,LF,'     COPY A CONTIGUOUS SECTION OF INFORMATION ON THE'
	DB CR,LF,'     CORVUS DRIVE ONTO A VIDEO TAPE FILE.'
	DB CR,LF,'  V: VERIFY'
	DB CR,LF,'     RE-READ A VIDEO TAPE FILE AND VERIFY THAT IT HAS'
	DB CR,LF,'     BEEN RECORDED CORRECTLY.  THIS IS DONE BY TESTING'
	DB CR,LF,'     THE  CRC  (A FORM OF CHECKSUM) OF EACH RECORD.'
	DB CR,LF,'  I: IDENTIFY'
	DB CR,LF,'     READ THE HEADER OF A VIDEO TAPE FILE AND LIST IT'
	DB CR,LF,'     ON THE CONSOLE.'
	DB CR,LF,'  R: RESTORE'
	DB CR,LF,'     COPY A VIDEO TAPE FILE BACK TO THE CORVUS DRIVE.'
	DB CR,LF,'     IT NEED NOT BE RESTORED TO THE SAME PLACE IT WAS '
	DB CR,LF,'     COPIED FROM.',CR,LF
	DB CR,LF,'  -  RETRY'
	DB CR,LF,'     THIS FUNCTION IS BUILT IN TO THE  VERIFY  AND  RESTORE'
	DB CR,LF,'     FUNCTIONS.  A RETRY WILL BE REQUESTED IF THE REDUNDANCY'
	DB CR,LF,'     BUILT INTO "THE MIRROR" RECORDING FORMAT WAS NOT'
	DB CR,LF,'     SUFFICIENT TO RECOVER FROM AN ERROR DETECTED IN ONE OR'
	DB CR,LF,'     MORE TAPE RECORDS.  IN THIS CASE, THE ERROR STATISTICS'
	DB CR,LF,'     WILL SHOW HOW MANY BLOCKS NEED RETRYS (NOTE: IF THIS'
	DB CR,LF,'     NUMBER IS ZERO THEN ALL OF THE DATA WAS RECOVERED).'
	DB CR,LF
     	DB CR,LF,' A CONTROL - C ISSUED IN RESPONSE TO A PROMPT WILL CAUSE'
	DB CR,LF,' AN EXIT BACK TO CP/M.  A NON DECIMAL INPUT, IN RESPONSE'
	DB CR,LF,' TO A PROMPT REQUESTING A NUMBER, WILL CAUSE A REPEAT OF'
	DB CR,LF,' THE QUESTION ( CONTROL - C WILL ALWAYS CAUSE AN EXIT).'
	DB CR,LF,' THE ONLY NUMERICAL INPUTS REQUIRED ARE ALL IN DECIMAL.'
	DB CR,LF,' THE  BACKUP  AND  RESTORE  COMMANDS MAY ASK FOR THE'
	DB CR,LF,' " STARTING DISC BLOCK # " AND THE " # OF BLOCKS " '
	DB CR,LF,' (IF YOU ARE NOT SAVING OR RESTORING AN ENTIRE DISC).'
	DB CR,LF,' THIS REFERS TO THE ACTUAL INTERNAL ORGANIZATION OF'
	DB CR,LF,' THE DRIVE - WHICH USES 512 BYTE SECTORS (BLOCKS).'
	DB CR,LF,' THE RELATION BETWEEN THE  BLOCK ADDRESS  '
	DB CR,LF,' AND THE USUAL  128 BYTE DISC ADDRESS  '
	DB CR,LF,' IS SIMPLE:',CR,LF
	DB CR,LF,'   DISC ADDRESS (128 BYTE) = 4 X BLOCK ADDRESS',CR,LF
	DB CR,LF,' THIS MAY CAUSE A SLIGHT PROBLEM IF YOU WANT TO SAVE '
	DB CR,LF,' OR RESTORE DISC DATA AT   DISC ADDRESSES (128 BYTE)'
	DB CR,LF,' THAT ARE NOT DIVISIBLE BY 4.  FOR REFERENCE,'
	DB CR,LF,' THE MAXIMUM BLOCK ADDRESS FOR VARIOUS CORVUS'
	DB CR,LF,' DRIVES ARE:',CR,LF
	DB CR,LF,'       18935   (REV A 10 MB DRIVE)'
	DB CR,LF,'       21219   (REV B 10 MB DRIVE)'
	DB CR,LF,'       38459   (REV B 20 MB DRIVE)'
	DB CR,LF,'       11219   (REV B  5 MB DRIVE)'
	DB CR,LF,'       11539   (REV H  6 MB DRIVE)'
	DB CR,LF,'       23699   (REV H 11 MB DRIVE)'
	DB CR,LF,'       35859   (REV H 20 MB DRIVE)'
	DB CR,LF,CR,LF,'$'
;
; ---- BUFFERS AND DATA ----
;
;
SBUF:	DS	2	; OLD STACK POINTER
MAXSC:	DS	3	; BUFFER FOR MAX BLOCK ADDRESS
SRTN:	DS	1	; BUFFER FOR RETURN CODE
RTLEN:	DS	2	; LENGTH OF RETURNED BLOCK
DADD:	DS	2	; DISC ADDRESS
BFPTR:	DS	2	; BUFFER POINTER
PRCTR:	DS	1	; COUNTER FOR BUFFER ROUTINES
DECBUF:	DS	2	; BUFFER FOR DECOUT ROUTINE
R1:	DS	1	; BUFFER FOR ERROR CODE
;
MSGPTR:	DS	2	; POINTER TO MESSAGE FOR  KTST ROUTINE
;
IDENT:	DB 10,0,1,0	; COMMAND SEQ. FOR IDENTIFY COMMAND
;
VERIF:	DB 10,1,1,0	; COMMAND SEQ. FOR VERIFY COMMAND
;
VERF1:	DB 10,6,1,0	; COMMAND FOR RETRY, VERIFY
;
ERCOM:	DB 10,2,0,0	; LIST ERRORS COMMAND
;
;
; --- FAKE COPY OF DATA FOR REV A STATUS STRING ---
;
REVADTA: DB	18	; # SECTORS/TRACK
	DB	3	; # HEADS
	DW	350	; # OF CYLINDERS
	DW	18936	; # OF 512 BYTE SECTORS
	DB	0
;
RTRBF:	DB	10	; RETRY COMMAND
	DB	3
R2:	DS	1	; # OF ERRORS (BUFFER)
CK2:	DS	1	; BUFFER FOR CHECKSUM
;
RTBCOM:	DB	12	; "REV B" RETRY COMMAND
	DS	1	; SPACE FOR DRIVE #
	DB	0	; SUBCOMMAND
	DS	1	; SPACE FOR CHECKSUM
;
RTBECOM: DB	12	; "REV B" RESTORE ERRORS COMMAND
	DS	1	; SPACE FOR DRIVE #
	DB	1	; SUBCOMMAND
	DS	1	; SPACE FOR CHECKSUM
;
RCOMD:	DB	RDCOM	; READ SECTOR 0 COMMAND BLOCK
	DS	1	; LEAVE SPACE FOR DRIVE #
	DW	0	; SECTOR ADDRESS 0
;
COMD:	DB	9	; BACKUP COMMAND
DRIVE:	DS	1	; BUFFER FOR DRIVE #
ID:	DB	1	; STANDARD ID #
BLEN:	DS	2	; BUFFER FOR LENGTH (IN 512 BYTE BLOCKS)
BKSTRT:	DS	2	; BUFFER FOR STARTING BLOCK #
CK1:	DS	1	; BUFFER FOR CHECKSUM
;
BUF:	DS	520	; HEADER BUFFER
STATBF:	DS	130	; BUFFER FOR STATUS STRING
TXBUF:	DS	200H	; TEXT BUFFER AREA
	DS	80	; STACK SPACE
STACK	EQU	$
;
;
	END
