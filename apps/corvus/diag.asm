; ------ CORVUS DISC DIAGNOSTIC PROGRAM ------
;		VERSION 2.6S/TT
;	  ( S-100/ TRS-80 II VERSION )
;		    BY BRK
;	    REVISED BY D. HO 12/1/82
;
; =============================================================
; Modified for Softbox by KRF  --  28 MAR 83
; =============================================================
;
;
;$I CRVSYS.S		; SYSTEM EQUATES
;	----	S-100/ TRS-80 II I/O PORT ADDRESSES & MASKS	----
;
STAT	EQU	16h	; STATUS I/O PORT
DATA	EQU	18h	; DATA I/O PORT
DRDY	EQU	10h	; MASK FOR DRIVE READY BIT
DRDYST	EQU	10h	; IF BIT 0 = 1 THEN DRIVE READY
DIFAC	EQU	20h	; MASK FOR DRIVE ACTIVE BIT
HTD	EQU	20h	; IF BIT 1 SET THEN HOST-TO-DRIVE STATUS
DTH	EQU	0	; IF BIT 1 = 0 THEN DRIVE-TO-HOST
;
;
;
;$I CDIAGNOS.BDY	; MAIN BODY OF CDIAGNOS
; ***************************************************************
;
;
;   THIS PROGRAM PROVIDES A FEW RELATIVELY SAFE DISC DIAGNOSTICS
;   FOR THE CORVUS DRIVE AS WELL AS PROVISIONS FOR SETTING UP
;   VARIOUS PARAMETERS IN THE CONTROLLER FIRMWARE.  THIS PROGRAM
;   CONTAINS ITS OWN CORVUS DISC DRIVERS, SO IT MAY BE USED
;   EVEN BEFORE THE OPERATING SYSTEM IS LINKED TO THE CORVUS.
;
; NOTE: THE DISC FORMAT CHECK OPTION WILL ONLY WORK ON SYSTEMS WITH
;	CONTROLLER CODE VERSION # >0.  IF FOR SOME REASON YOU
;	DO NOT WANT TO UPDATE IT FROM VERSION 0, BUT NEED TO
;	FIX SOME BAD DISC SECTORS, YOU CAN USE THE UPDATE
;	OPTION TO TEMPORARILY SWITCH CONTROLLER CODES TO RUN
;	THIS PROGRAM (FROM YOUR FLOPPY CP/M) THEN SWITCH BACK
;	TO VERS. 0 CONTROLLER CODE.  ALSO, THE MANUAL TEST MODE MAY
;	NOT BE VERY USEFUL ON A CONSTELLATION SYSTEM BECAUSE
;	THE DISC CONTROLLER IS NOT LISTENING TO THE INDIVIDUAL
;	NODE COMPUTERS UNLESS THE READY LINE HIGH FOR THAT COMPUTER.
;	THIS WILL NOT HAPPEN FOR MORE THAN 20-100 USEC OR SO IF
;	ONE IS ONLY POKING BYTES AT THE DRIVE BY HAND.
;
;
; REV 2.2 - KO	  THERE IS NO FUNCTIONAL CHANGE IN THIS REVISION.
;		THE CHANGES MADE ARE TO ISOLATE THE SYSTEM
;		DEPENDENT PORTIONS OF THE PROGRAM.
;		THIS SOURCE HAS BEEN PRODUCED USING INCLUDE FILES.
;		ANY COMMENTS CONTAINING $I FILENAME SHOULD BE
;		IGNORED.
;
;
; REV 2.3 - KO	  CHANGES MADE ALLOW FOR CONTROLLER CODE TO BE
;		UPDATED ON SYSTEMS THAT DO NOT HAVE ENOUGH MEMORY
;		TO READ THE ENTIRE CODE IN AT ONCE.  AS MUCH OF THE
;		THE CONTR. CODE IS READ INTO MEMORY AS CAN BE.  IF
;		IT WON'T FIT THE USER IS PROMPTED IF THEY WANT TO
;		CONTINUE.  IF CODE IS BEING READ FROM CORVUS DRIVE
;		AND IT WON'T FIT, THEN THE USER SHOULD NOT CONTINUE.
;		  ALSO, IT IS NO LONGER NECESSARY TO OVERLAY THE
;		CDIAGNOS.COM FILE WITH THE PREP BLOCK.  IT IS NOW
;		INCLUDED IN THE .ASM FILE IN THE FORM OF DB
;		STATEMENTS.
;
; REV 2.4 - BRK FIX MINOR BUG IN SPARE TRACK EDITOR
;
; REV 2.5 - BRK UPDATE FOR REV H DRIVES BY CHANGING SPARE TRACK
;	 	ROUTINES TO ALLOW FOR NEW SPARE TRACK TABLE AT END OF
;		BLOCK 1  AND  ADD "PARK" MENU OPTION.
;
; REV 2.6 - BRK CORRECTED BUG ACCIDENTALLY ADDED IN V2.5 TO OPTION 8
;		PROCESSOR
;
; ***************************************************************
;
; ---- CP/M EQUATES -----
;
FCB	EQU	5CH	; STD FCB
BDOS	EQU	05	; BDOS ENTRY POINT
OFST	EQU	806H	; CCP OFFSET FROM BDOS ENTRY POINT
CHIN	EQU	1	; BDOS COMMAND FOR CONSOLE INPUT
CHOUT	EQU	2	; BDOS COMMAND FOR CONSOLE OUTPUT
RDBUF	EQU	10	; BDOS COMMAND TO READ TEXT STRING
OPEN	EQU	15	; BDOS COMMAND TO OPEN FILE FOR READING
SRCH	EQU	17	; BDOS COMMAND TO SEARCH FOR FILE
READ	EQU	20	; BDOS COMMAND TO READ A SECTOR
SDMA	EQU	26	; BDOS COMMAND TO SET DMA ADDRESS
;
;
CR	EQU	0DH	; CARRIAGE RETURN
LF	EQU	0AH	; LINE FEED
;
;
; ---- CORVUS DISC EQUATES ----
;
FCKCOM	EQU	7	; FORMAT CHECK COMMAND
NSTAT	EQU	10H	; REV B STATUS COMMAND
UCOM	EQU	11H	; REV B UNIV. COMMAND
;
;
FMTCHAR	EQU	0E5H	; CHAR. TO FORMAT REV B AND REV H DRIVES WITH
;
; DO NOT CHANGE RDCOM AND WRCOM WITHOUT ALSO CHANGING THE TEST IN
; THE VCHK ROUTINE.
;
RDCOM	EQU	12H	; READ COMMAND (FOR 128 BYTES/SECTOR)
WRCOM	EQU	13H	; WRITE COMMAND (FOR 128 BYTES/SECTOR)
;
;
	ORG 100H	; STANDARD CP/M TPA ORIGIN
;
START:	LXI	H,0
	DAD	SP	; GET STACK POINTER IN (H,L)
	SHLD	SBUF	; SAVE IT
;   -- SETUP DIRECT CONSOLE I/O JUMPS ---
	LHLD	1	; GET ADDRESS OF WARM BOOT (BIOS+3)
	LXI	D,3
	DAD	D	; COMPUTE ADDRESS OF CONST
	SHLD	CONST+1	; PATCH IN JUMP
	DAD	D
	SHLD	CONIN+1
	DAD	D
	SHLD	CONOUT+1
	JMP	SIGNON	; SIGN ON AND START PROGRAM
;
CONST:	JMP	0	; JUMP TO BIOS ROUTINES
CONIN:	JMP	0
CONOUT:	JMP	0
;
SIGNON:	LXI	SP,STACK	;SETUP LOCAL STACK
	LXI	D,SMSG		;POINT TO MESSAGE
	CALL	PTMSG		; PRINT SIGN ON MESSAGE
Q1:	LXI	D,MSG2
MN0:	CALL	PTMSG		; LIST TASK MENU
MN1:	LXI	SP,STACK	;RESET STACK
	LXI	D,MSG3
	CALL	PTMSG		; ASK FOR CHOICE
MN2:	LXI	H,TSKTAB	; POINT TO TASK TABLE
	JMP	DOMNU		; SELECT CHOICE AND BRANCH
;
; --- TASK TABLE ---
;
TSKTAB:	EQU	$
	DB	(TSKTBE-$-1)/3	; # OF COMMANDS
	DB	'0'		; COMMAND INDENTIFIER
	DW	Q1		; COMMAND ADDRESS
	DB	'1'
	DW	INST
	DB	'2'
	DW	FCHK
	DB	'3'
	DW	RDCODE
	DB	'4'
	DW	SVRTST
	DB	'5'
	DW	MANTST
	DB	'6'
	DW	UPDATE
	DB	'7'
	DW	MAP
	DB	'8'
	DW	CONSTL
	DB	'P'
	DW	PARK		; REV H "PARK" FUNCTION
	DB	'9'
	DW	EXIT
TSKTBE	EQU	$		; END OF TASK TABLE
;
;
; --- LIST INSTRUCTIONS COMMAND ---
;
INST:	LXI	D,MSGI
	JMP	MN0
;
; --- READ CONTROLLER CODE COMMAND ---
;
RDCODE:	CALL	INITX		; INITIALIZE CONTROLLER AND READ VERSION #
	CPI	8FH		; IS IT AN ILLEGAL COMMAND?
	JZ	RDCB		; YES, MUST BE REV. B CONTROLLER
	ANI	0F0H		; MASK OUT # OF DRIVES
	RRC			; SHIFT DOWN TO LOWER NIBBLE
	RRC
	RRC
	RRC
	PUSH	PSW		; SAVE IT
	LXI	D,MSG11
	CALL	PTMSG
	POP	PSW
RDC1:	CALL	DECBT		; OUTPUT IN DECIMAL
RDC2:	LXI	D,CRLF
	JMP	MN0		; BACK TO MENU
;
RDCB:	CALL	BSTAT		; READ REV B STATUS STRING
	JC	RDC2		; IF ERROR, EXIT BACK TO MENU
	CALL	PCRLF
	CALL	SPACE
	MVI	B,31		; SET LENGTH OF STRING
	LXI	D,STATBF	; POINT TO START OF STRING
	CALL	PTSTR		; PRINT STRING
	LXI	D,MSGV		; 'REVISION #'
	CALL	PTMSG
	LDA	STATBF+31	; GET REVISION #
	CALL	DECBT		; PRINT IT OUT
	LXI	D,MSGRV
	CALL	PTMSG
	LDA	STATBF+32	; GET ROM VERSION
	CALL	DECBT		; OUTPUT  IN DECIMAL
	LXI	D,MSGDZ		; "DISK SIZE"
	CALL	PTMSG
	LHLD	STATBF+37	; GET SIZE
	CALL	DECOUT		; PRINT IT OUT
	JMP	RDC2		; PRINT OUT AND BACK TO MENU
;
; --- DISC FORMAT CHECK COMMAND ---
;
FCHK:	LXI	H,MSG10		; POINT TO MESSAGE
	SHLD	MSGPTR		; SAVE IT
	CALL	INITX		; INITIALIZE CONTROLLER AND READ VERSION #
	JNZ	FC1		; IF NOT REV. 0, CONTINUE
	LXI	D,MSG6		; IF REV. 0, ISSUE MESSAGE AND RESTART
	JMP	MN0
FC1:	PUSH	PSW		; SAVE RETURN NUMBER
	CALL	GTDRV		; ASK FOR AND GET DRIVE #
	POP	PSW		; GET NUMBER BACK
	CPI	8FH		; WAS IT AN ILLEGAL COMMAND?
	JNZ	VERF		; NO, SO MUST BE REV A CONTROLLER
	CALL	BSTAT1		; READ REV B STATUS STRING
	JC	MN1		; IF ERROR
	CALL	PREP1		; SHIFT TO DIAG MODE IN REV B
	JC	FC2		; IF ERROR
	MVI	A,FCKCOM	; GET DISC FORMAT CHECK COMMAND
	CALL	WAITO		; SEND IT
	CALL	VERF1		; DO IT
	PUSH	PSW		; SAVE STATUS
	CALL	EXPREP		; EXIT PREP MODE
	POP	PSW
	JC	MN1		; EXIT IF ERROR
	JMP	VLST		; LIST ERRORS AND BACK TO MENU
;
FC2:	CALL	EXPREP		; EXIT PREP MODE
	JMP	MN1
;
VERF:	CALL	REVAFIX		; COPY DATA FOR REV A STATUS
	MVI	A,FCKCOM	; GET DISC FORMAT CHECK COMMAND
	CALL	WAITO		; SEND IT
	LDA	DRIVE		; GET DRIVE #
	CALL	WAITO		; SEND IT
	CALL	VERF1		; DO IT
	JC	MN1		; IF ERROR
	JMP	VLST		; LIST ERRORS AND BACK TO MENU
;
VERF1:	LXI	D,MSG10
	CALL	PTMSG
	CALL	TURNKT		; WAIT FOR TURN AROUND
	LXI	H,BUFF		; POINT TO BUFFER
	SHLD	RADD		; SAVE FOR R/W OPERATION
	CALL	GETBLK		; READ IN RETURN DATA
	CALL	WERR2		; TEST ERROR CONDITION
	RET
;
; --- HEAD SERVO TEST ---
;
SVRTST:	LXI	H,MSG4		; POINT TO MESSAGE FOR KTST
	SHLD	MSGPTR
	MVI	A,RDCOM
	STA	RWCOM		; SET FOR READ MODE
	CALL	GTDRV		; ASK FOR AND GET DRIVE #
	CALL	INITX		; INITIALIZE CONTROLLER AND FIX READ COMMAND
	CPI	8FH		; TEST IF REV B CONTROLLER
	CALL	REVAFIX		; SETUP STATUS STRING FOR REV A
	JNZ	SVRX		; IF REV A DRIVE
	CALL	BSTAT1		;  IF REV B, GET STATUS STRING
	JC	RDC2		; RETURN TO MENU IF ERROR
	MVI	A,RDCOM		; SET REV-B READ COMMAND
	STA	RWCOM
SVRX:	LXI	H,BUFF
	SHLD	RADD		; SET R/W BUFFER ADDRESS
	LXI	H,128
	SHLD	SLEN		; SET SECTOR LENGTH
;
; --- COMPUTE OUTER SEEK ADDRESS ---
;
	LHLD	STATBF+37	; GET LOWER PART OF MAX BLOCK ADD
	LDA	STATBF+39	;  AND GET ITS UPPER BYTE
	DAD	H		; MULTIPLY BY 4 ( FOR 128 BYTE SEC)
	ADC	A
	DAD	H
	ADC	A
	ANI	0FH		; GET UPPER NIBBLE OF ADDRESS
	RLC			; SHIFT UP TO UPPER NIBBLE
	RLC
	RLC
	RLC
	MOV	C,A
	LDA	DRIVE
	ADD	C		; MERGE WITH DRIVE #
	STA	DRIVEU		; SAVE IT
	LXI	D,-1000
	DAD	D		; SHIFT ADDRESS DOWN A LITTLE
	SHLD	DADDU		; SAVE IT
;
SVR1:	LDA	DRIVE		; GET DRIVE #
	ANI	0FH		; MASK OFF UPPER NIBBLE
	STA	DRIVE		; RE-SAVE IT
	LXI	H,0
	SHLD	DADD		; SET FOR DISC ADDRESS 0
	CALL	RWSEC		; READ ONE SECTOR
;
	CALL	KTST
	CPI	'C'-40H
	JZ	MN1		; TO STOP TEST
;
SVR2:	LDA	DRIVEU		; GET DRIVE # + EXT. ADDRESS
	STA	DRIVE
	LHLD	DADDU		; GET LOWER PART OF DISC ADDRESS
	SHLD	DADD		; SET FOR DISC ADDRESS 0
	CALL	RWSEC		; READ ONE SECTOR
	JMP	SVR1
;
; --- MANUAL CONTROLLER READ/WRITE TEST ---
;
MANTST:
	LXI	D,MSG12
	CALL	PTMSG		; PRINT WARNING MESSAGE
MST1:	LXI	D,MSG13
	CALL	PTMSG		; ISSUE PROMPT
MST2:	CALL	CONNC		; GET COMMAND
	MOV	C,A		; INSURE SEARCH FOR UPPER CASE CHAR
	LXI	H,TSTAB		; POINT TO COMMAND TABLE
	MVI	B,(TSTBE-TSTAB)/3	; # OF COMMANDS
	CALL	STAB		; SEARCH TABLE
	JC	MST2		; IF INVALID, TRY AGAIN
	PUSH	D		; PUT ADDRESS ON STACK
	JMP	COUT		; ECHO COMMAND AND VECTOR TO SERVICE ROUTINE
;
TSTAB	EQU	$		; COMMAND TABLE
	DB	'R'		; COMMAND CHARACTER
	DW	RDPT		; COMMAND ADDRESS
	DB	'W'
	DW	ODPT
	DB	'S'
	DW	RDST
	DB	'E'
	DW	MN1
TSTBE	EQU	$

;	2.2 -	THE RDPT, ODPT, RDST ROUTINES HAVE BEEN MOVED TO
;		THE END OF THE CODE SECTION

;
;
; --- UPDATE CONTROLLER CODE ---
;
UPDATE:
	MVI	A,0FFH		; 2.3 - RESET END OF FILE FLAG
	STA	EOFLG		;
	MVI	A,1
	STA	SKFG		; SET TO SKIP REV B
				;  TABLE SECTORS
	STA	FMFG		; SET TO UPDATE CODE ONLY
CF0:	LXI	H,UMSG		; SET INPUT PROMPT
	SHLD	MSGPTR
;
	CALL	GTNAM		; GET FILE NAME
	CALL	MAKFCB		; CREATE FILE CONTROL BLOCK
	JC	NERR		; IF ILLEGAL NAME
;
	LXI	D,INI		; POINT TO TYPE FOR UPDATE WITH DEFAULTS
	LXI	H,FCB+9		; POINT TO FILE TYPE
	MVI	C,3
	CALL	COMPARE
	JNZ	CF2		; IF NO MATCH
	XRA	A		; SET TO USE DEFAULTS IN CODE
	JMP	CF3
CF2:	LXI	D,FMT		; POINT TO TYPE FOR FORMAT AND UPDATE
	LXI	H,FCB+9		; POINT TO FILE TYPE
	MVI	C,3
	CALL	COMPARE
	JNZ	CF1		; IF NO MATCH
	XRA	A
	STA	FMFG		; SET FOR FORMAT AND UPDATE
CF3:	STA	SKFG		; SET FOR NO SKIP ON UPDATE
	LXI	D,FCB+9		; SET DESTINATION AT FCB
	LXI	H,TYP		; SET SOURCE
	MVI	C,3		; SET LENGTH
	CALL	MOVE		; COPY 'CLR' INTO FCB
CF1:	LXI	D,TYP		; POINT TO DESIRED TYPE (.CLR)
	LXI	H,FCB+9		; POINT TO FILE TYPE
	MVI	C,3		; LENGTH OF FILE TYPE
	CALL	COMPARE		; TEST FILE TYPE
	JNZ	NERR		; IF ERROR
;
OPENF:	LXI	D,FCB		; POINT TO FCB
	MVI	C,OPEN		; GET OPEN COMMAND
	CALL	BDOS		; OPEN FILE
	INR	A
	JNZ	RDIT		; IF PRESENT, READ IT IN
	LXI	D,UMSG9
	CALL	PTMSG		; ISSUE FILE NOT FOUND MSG
NERR:	LXI	D,UMSG7		; COMMAND FORMAT MESSAGE
	JMP	MN0		; PRINT MESSAGE AND BACK TO MENU
;
RDIT:	XRA	A
	STA	WFLG		; CLEAR CCP OVERLAY FLAG
	STA	CTFG		; ASSUME REV A CONT. CODE
	LHLD	BDOS+1		; GET ADD OF BIOS+3
	DCX	H
	SHLD	TOP		; SAVE ADD. OF TOP OF 'SAFE' RAM
	CALL	RDCPM		; READ IN CP/M FILE TO MEMORY BUFFER
				; 2.3 - ADD ERROR CHECKS
	JC	MN1		; RETURN TO MENU IF ERROR
	LXI	D,MSGE2		; POINT TO ERROR
	JZ	MN0		; LIST & RET TO MENU IF READ ERROR
;
	LHLD	RADD		; GET LAST DMA LOCATION
	SHLD	CDEND		; SAVE IT
	LXI	D,2+OFST	; GET OFFSETS
	DAD	D
	XCHG
	LHLD	BDOS+1		; GET LOCATION OF BDOS ENTRY
	XCHG
	CALL	SUBDE		; (H,L)=(H,L)-(D,E)
	JC	RDIT1		; IF NO OVERLAY OF CCP, PROCEED
	MVI	A,1
	STA	WFLG		; IF OVERLAY, SET TO WARM BOOT
;
RDIT1:	LXI	H,BUFF		; POINT TO START OF BUFFER
	LXI	D,TEST		; POINT TO EXPECTED TEST CODE
	MVI	C,9		; LENGTH OF CODE
	CALL	COMPARE		; COMPARE THEM
	JNZ	RDIT3		; IF NOT VALID FORMAT
	MVI	C,6		; LENGTH OF REV B SEGMENT
	CALL	COMPARE		; IS IT REV B CONT. CODE?
	JNZ	RDITX		; NO, SO CONTINUE
	MVI	A,1
	STA	CTFG		; SET CODE TYPE FLAG FOR REV B
;
RDITX:	LDA	FMFG		; WAS FORMAT REQUESTED
	ORA	A
	JNZ	RDIT2		; NO, SO PROCEED
	LXI	D,FMSG		; POINT TO FORMAT MESSAGE
	CALL	PTMSG		; PRINT IT OUT
	CALL	YES		; OK?
	JNZ	MN1
	LXI	D,JMSG		; ASK IF JUMPER IS INSTALLED
	CALL	PTMSG
	CALL	YES
	JNZ	MN1
	CALL	GTDRV		; GET DRIVE #
	LXI	D,TMSG		; ADVISE OF TIME
	CALL	PTMSG
	LDA	CTFG
	ORA	A		; REV A OR B?
	JZ	FMTA		; REV A SO DO IT
	JMP	FMTB		; REB B SO DO IT
;
RDIT2:	CALL	PRTHDR		; 2.3 -  CALL SUBROUTINE
	LXI	D,JMSG
	CALL	PTMSG		; ASK IF JUMPER IS INSTALLED
	CALL	YES
	JNZ	MN1		; EXIT IF NO JUMPER
	LXI	D,UMSG2
	CALL	PTMSG		; WRITE CODE TO DISC?
	CALL	YES
	JZ	UPDAT		; YES, DO IT
	JMP	MN1		; NO,  SO EXIT
RDIT3:	LXI	D,UMSG6		; POINT TO ERROR MESSAGE
	JMP	MN0		; BACK TO MENU
;
UPDAT:	CALL	GTDRV		; GET DRIVE #
	LDA	CTFG		; GET CONT. CODE TYPE FLAG
	ORA	A		; REV A OR B ?
	JNZ	UPDATEB		; REV B, SO DO IT
	JMP	UPDATEA		; 2.3 - ADD JMP
;
; --- FORMAT REV A DRIVE ---
;
FMTA:	MVI	A,1
	CALL	WAITO		; SEND OUT FORMAT COMMAND
	LDA	DRIVE
	CALL	WAITO		; SEND OUT DRIVE #
	CALL	WERR		; WAIT FOR TURN AROUND
	CALL	PRTHDR		; 2.3 - CALL PRINT HEADR ROUTINE
;
;
; --- UPDATE CONTROLLER CODE ON REV A DRIVE ---
;
UPDATEA: LXI	H,0
	SHLD	DADD		; SET DISC ADDRESS
	LXI	H,512
	MVI	A,3
	STA	RWCOM		; SET REV A WRITE COMMAND
	SHLD	SLEN		; SET SECTOR SIZE
	MVI	A,23		; # OF 512 BYTE SECTORS
	STA	NSEC
	CALL	RWBLK		; WRITE BLOCK TO DRIVE
	JC	MN1		; IF ERROR
	LXI	H,24
	SHLD	DADD		; SET DISC ADDRESS
	MVI	A,23
	SHLD	NSEC		; SET LENGTH OF WRITE
	STA	NSEC		; SET # OF BLOCKS
	LHLD	CODE
	SHLD	RADD		; SET RAM ADDRESS
	CALL	RWBLK		; WRITE BLOCK TO DISC
	JC	MN1		; EXIT IF ERROR
UDAT1:	LXI	D,UMSG8		; POINT TO EXIT MESSAGE
	JMP	MN0		; BACK TO MENU
;
;
; --- FORMAT REV B DRIVE ---
;
;		2.3 - DON'T EXIT PREP MODE TILL AFTER UPDATE
;
FMTB:	CALL	PREP		; WRITE DOWN DIAG CODE
	JC	UDBX		; IF ERROR
	MVI	A,1
	CALL	WAITO		; SEND OUT FORMAT COMMAND
	LXI	B,512		; SET SECTOR SIZE
FMTBL:	MVI	A,FMTCHAR	; STD IBM FMT CHAR.
	CALL	WAITO		; SEND IT TO CONTROLLER
	DCX	B		; COUNT DOWN
	MOV	A,B
	ORA	C
	JNZ	FMTBL		; LOOP UNTIL DONE
	CALL	WERR		; TEST RTN CODE
	CALL	PRTHDR		; 2.3 - PRINT HEADR
;
; --- UPDATE CONTROLLER CODE ON REV B DRIVE ---
;
;	  2.3 - CHECK IF FORMAT REQUESTED PRIOR TO UPDATE
;
UPDATEB: LDA	FMFG	; GET FORMAT FLAG
	ORA	A	; WAS FORMAT REQUESTED
	CNZ	PREP1	; IF NOT THEN GO INTO PREP MODE
	JC	UDBX	; IF ERROR, TRY EXITING PREP MODE
	LXI	H,0
	SHLD	DADD	; SET STARTING DISC ADDRESS
	LXI	H,512
	SHLD	SLEN	; SET SECTOR SIZE
	LDA	CDLEN	; GET # OF SECTORS TO WRITE
	STA	NSEC	; SET IT
;
UPDBL:	LDA	DADD+1	; GET HEAD/SEC ADDRESS
	MOV	B,A	; SAVE IT
	LDA	SKFG	; GET SKIP FLAG
	ORA	A	; SKIP TABLE SECTORS?
	JZ	UDB1	; NO
	MVI	A,1	; YES, IF
	CMP	B	;  IT IS ADD 1
	JZ	UDB2
	MVI	A,3	; YES, IF
	CMP	B	;  IT IS ADD 3
	JZ	UDB2
UDB1:	MVI	A,33H	; GET WRITE COMMAND FOR REV B CONT.
	CALL	WAITO	; SEND IT
	MOV	A,B	; GET HEAD/SEC ADDRESS
	CALL	WAITO	; SEND IT
	LHLD	RADD	; GET POINTER TO CODE IN RAM
	CALL	WTSEC	; WRITE SECTOR TO CONTROLLER
	JC	UDBX	; EXIT IF ERROR
;
;	2.3 -	  ADD CODE TO READ THE REST OF CONTROLLER
;		  CODE FILE IF IT WOULDN'T FIT IN MEMORY
;
UDB2:	LHLD	RADD	; GET RAM ADD.
	LXI	D,512	; GET SECTOR SIZE
	DAD	D	; POINT TO NEXT BLOCK
	SHLD	RADD	; SAVE IT
	CALL	INCSEC	; INCREMENT SECTOR POINTER
			; 2.3T - OUTPUT WRITE COUNTER MESSAGE
;	LXI	D,TMSGW	; POINT TO WRITE COUNT MESSAGE
;	CALL	PTMSG	; WRITE IT
;	LXI	H,NSEC	; POINT TO WRITE COUNTER
;	MOV	A,M	; GET COUNT INTO ACC
;	CALL	DECBT	; PRINT OUT COUNT
;	LXI	D,UMSGE
;	CALL	PTMSG	; WRITE UNITS OF CODE LENGTH
			; END TEST CODE
	LXI	H,NSEC	; POINT TO SECTOR COUNTER
	DCR	M	; COUNT DOWN
	JNZ	UPDBL	; IF NOT ZERO, CONTINUE
;
	CALL	RDCPM	; ELSE GET THE REST OF CODE
	JC	UDBX	; EXIT IF ERROR
	JZ	UDBX1	; EXIT IF NO MORE CODE
	LHLD	RADD	; GET NEXT READ ADDRESS
	SHLD	CDEND	; SAVE END OF CODE
	LXI	D,BUFF	; GET BEGINNING OF CODE
	CALL	SUBDE	; HL <- BYTES OF CODE
	MOV	A,H	; A <- HL/256
	ORA	A	; CLEAR CARRY BIT
	RAR		; A <- HL/512
	STA	NSEC	; PUT BLK CNT INTO COUNTER
	LXI	H,CDLEN	; POINT TO CODE LENGTH
	ADD	M	; ADD NEW CNT
	STA	CDLEN	; SAVE IT
			; 2.3 - OUTPUT CODE LENGTH MESSAGE
	LXI	D,UMSGL	; POINT TO CODE LENGTH MESSAGE
	CALL	PTMSG	; WRITE IT
	LDA	CDLEN	; GET CODE LENGTH
	CALL	DECBT	; PRINT OUT LENGTH OF CODE
	LXI	D,UMSG5
	CALL	PTMSG	; WRITE UNITS OF CODE LENGTH
	LXI	H,BUFF	; GET BEGIN ADDR INTO HL
	SHLD	RADD	; SET RAM ADDRESS
	JMP	UPDBL	; LOOP UNTIL DONE
;
INCSEC:	LXI	H,DADD+1 ; POINT TO ADDRESS COUNTER
	INR	M	; INCREMENT IT
	MOV	A,M	; GET IT
	ANI	1FH	; MASK OUT HEAD #
	CPI	20	; HAVE WE FILLED OUT TRACK
	RNZ		; NO, SO RETURN
	MOV	A,M	; YES, SO GET COUNTER
	ANI	0E0H	; ZERO SECTOR COUNT
	ADI	20H	; INCREMENT HEAD COUNT
	MOV	M,A	; UPDATE COUNTER
	RET
;
UDBX:	CALL	EXPREP	; EXIT PREP MODE
	JMP	MN1	; BACK TO MENU
UDBX1:	CALL	EXPREP
	JMP	UDAT1	; PRINT EXIT MESSAGE AND BACK TO MENU
;
; ---- PRTHDR - PRINT HEADER ROUTINE ----
;
;		2.3 -	MAKE THIS CODE A SUBROUTINE
PRTHDR:	LXI	D,UMSG3
	CALL	PTMSG		; PRINT LABEL
	LXI	D,BUFF		; POINT TO ASCII HEADER
	CALL	PTMSG		; PRINT IT OUT
	INX	D		; POINT TO START OF CODE
	XCHG
	SHLD	CODE		; SAVE POINTER
	SHLD	RADD
	XCHG			; GET INTO (D,E)
	LHLD	CDEND		; GET END OF CODE IN (H,L)
	CALL	SUBDE		; (H,L)=(H,L)-(D,E)
				; (H,L) NOW HAS LENGTH OF CODE
	MOV	A,H		; GET (A)=(H,L)/256
	ORA	A		; CLEAR CARRY
	RAR			; A=LENGTH/512=SIZE IN BLOCKS
	STA	CDLEN		; SAVE LENGTH IN 512 BYTE SECTORS
	LXI	D,UMSG4
	CALL	PTMSG		; BRACKET HEADER MESSAGE
	LXI	D,UMSGL		; 2.3 - POINT TO CODE LENGTH MESSAGE
	CALL	PTMSG		; WRITE IT
	LDA	CDLEN		; GET CODE LENGTH
	CALL	DECBT		; PRINT OUT LENGTH OF CODE
	LXI	D,UMSG5
	CALL	PTMSG		; WRITE UNITS OF CODE LENGTH
	RET			;
;
;
; --- DISPLAY AND CHANGE DRIVE MAPPING PARAMS. ---
;
MAP:	CALL	INITX	; RE-SYNC DRIVE AND FIND TYPE
	CPI	8FH	; IS IT A "REV A" DRIVE?
	JNZ	REVA	; YES, SO EXIT
	CALL	BSTAT	; GET REV B STATUS STRING
	JC	MN1	; IF ERROR, BACK TO MENU
	MVI	A,1	; SET TO GET BLOCK 1
	STA	DADD
	MVI	A,32H	; SET READ COMMAND
	STA	RWCOM
	CALL	RWCBLK	; READ IN CONTROLLER CODE BLOCK
;
	CALL	CPYO2N	; COPY 'OLD' REV B TABLE INTO REV H TABLE
;
	CALL	DSPARE	; DISPLAY SPARE TRACK TABLE
	CALL	CRTST	; WAIT FOR CR TO CONTINUE
	CALL	DINTL	; DISPLAY INTERLEAVING
	CALL	CRTST
	CALL	DVDO	; DISPLAY VDO TABLE
	XRA	A
	STA	CFLG	; CLEAR BLOCK UPDATE FLAG
			;  ( SET IT IF IT IS CHANGED)
	LXI	D,MPMSGI
	CALL	PTMSG	; GIVE WARNING OF DANGER
	CALL	YES	; OK TO CONTINUE?
	JNZ	Q1	; NO, BACK TO MAIN MENU
MAP1:	LXI	D,MPMSG1 ; POINT TO MAP SUB MENU
	CALL	PTMSG	; PRINT IT OUT
	LXI	H,MPTAB	; POINT TO OPTION TABLE
	JMP	DOMNU	; VECTOR TO CHOSEN OPTION
;
MPTAB	EQU	$
	DB	(MPTBE-$-1)/3	; LENGTH OF TABLE
	DB	'S'
	DW	EDSPARE
	DB	'I'
	DW	EDINTL
	DB	'V'
	DW	EDVDO
	DB	'E'
	DW	EXMAP
MPTBE	EQU	$
;
; --- EXIT MAP ROUTINE ---
;
EXMAP:	MVI	A,1		; SET FOR BLOCK 1
	STA	CBLK		; SAVE IT
EXUD:	LDA	CFLG		; LOOK AT UPDATE FLAG
	ORA	A
	JZ	Q1		; IF NO CHANGE, EXIT BACK
	LXI	D,MPMSG2	; ASK IF OK TO UPDATE
	CALL	PTMSG
	CALL	YES
	JNZ	Q1		; NO, SO BACK TO MAIN MENU
	LDA	CBLK		; GET BLOCK #
	STA	DADD
	MVI	A,33H		; WRITE COMMAND
	STA	RWCOM
;				; --- FIX BUG IN 2.5 (2.6 VERSION)
	LDA	CBLK		; GET BLOCK #
	CPI	1		; IS IT BLOCK 1
	JNZ	EXM2		; NO, SO SKIP COPY OF SPARE TRACK TABLE
;
	CALL	CPYN2O		; COPY FIRST 8 ENTRYS OF REV H TABLE
				;  BACK TO REV B TABLES
;
EXM2:	CALL	RWCBLK		; DO IT
	JMP	Q1		; BACK TO MENU
;
REVA:	LXI	D,REVAMSG
	CALL	PTMSG	; ' NOT AVAIL. ON REVA'
	JMP	Q1	; BACK TO MAIN MENU
;
; --- EDIT SPARE TRACK TABLE ---
;
EDSPARE:
	CALL	DSPARE	; DISPLAY TABLE
	LXI	D,SPRMSG1  ; PROMPT FOR ACTION
	CALL	PTMSG
	LXI	H,EDSTAB ; POINT TO VECTOR TABLE
	JMP	DOMNU	; BRANCH TO CHOICE
;
EDSTAB	EQU	$
	DB	(EDSTBE-$-1)/3 ; TABLE LENGTH
	DB	'A'
	DW	ADDSPARE
	DB	'R'
	DW	REMVSPR
	DB	'E'
	DW	MAP1
EDSTBE	EQU	$
;
; --- ADD ELEMENT TO SPARE TRACK TABLE ---
;
ADDSPARE:
	CALL	FINDSPR		; FIND INSERT POSITION IN TABLE
	JNC	ADDS2		; IF POSITION IS AVAIL.
	LXI	D,ADMSG1	; 'NO ROOM LEFT'
	CALL	PTMSG
	JMP	MAP1		; BACK TO UPPER MENU
ADDS2:	PUSH	H		; SAVE POINTER
ADDS3:	LXI	D,ADMSG2	; ASK FOR NEW TRACK #
	CALL	PTMSG
	CALL	INDEC		; GET IT
	JC	ADDS3		; IF ERROR
	XCHG
	POP	H		; GET INSERT LOCATION
	CALL	PTDE		; INSERT IN TABLE
	JMP	RMV5		; RE-ORDER TABLE AND RETURN
;
; --- REMOVE ENTRY FROM SPARE TRACK TABLE ---
;
REMVSPR:
	CALL	FINDSPR		; INIT END OF TABLE
	LXI	D,BUFF+512-64	; POINT TO START OF TABLE
	CALL	SUBDE
	MOV	A,L
	ORA	H
	JNZ	RMV1		; IF THERE IS A TRACK TO REMOVE
	CALL	PCRLF
	JMP	EDSPARE		; BACK TO MENU
RMV1:	LXI	D,RM1MSG
	CALL	PTMSG		; ASK FOR # TO REMOVE
	CALL	INDEC		; GET IT
	JC	RMV1		; IF ERROR
	SHLD	DADD		; TEMPORARY SAVE
	LXI	D,DADD		; POINT TO THIS LOCATION
	LXI	H,BUFF+512-64	; POINT TO START OF TABLE
	LDA	NSPR		; GET MAX # OF ENTRYS
	MOV	B,A
RMV2:	PUSH	H
	PUSH	D
	MVI	C,2		; COMPARE LENGTH
	CALL	COMPARE
	POP	D
	POP	H
	JZ	RMV4		; IF EQUAL
	INX	H
	INX	H
	DCR	B
	JNZ	RMV2		; LOOK FOR MATCH THRU TABLE
	LXI	D,RM2MSG	; 'ENTRY NOT FOUND'
	CALL	PTMSG
	JMP	EDSPARE
;
RMV4:	LXI	D,-1
	CALL	PTDE		; REMOVE ENTRY
RMV5:	CALL	BSORT		; RE-SORT TABLE
	MVI	A,1
	STA	CFLG		; NOTIFY OF CHANGE
	JMP	EDSPARE
;
;
; --- BUBBLE SORT OF SPARE TRACK TABLE ---
;
BSORT:	LXI	H,BUFF+512-64	; POINT TO START OF TABLE
	SHLD	RADD		; SAVE POINTER
BS1:	LDA	NSPR		; SET TABLE LENGTH
	MOV	C,A
	MVI	B,0		; CLEAR PERMUTATION FLAG
BS2:	CALL	GTDE		; GET FIRST ENTRY
	PUSH	D		; SAVE IT
	CALL	GTDE		; GET NEXT ENTRY
	POP	H
	XCHG
	CALL	COMPDE		; COMPARE THEM
	JNC	BS3		; IF IN INCREASING ORDER
	XCHG
	PUSH	H		; SAVE VALUE
	LHLD	RADD		; GET INSERT POINTER BACK
	CALL	PTDE
	POP	D
	CALL	PTDE
	MVI	B,1		; SET PERMUTATION FLAG
BS3:	LHLD	RADD		; GET POINTER BACK
	INX	H		; POINT TO NEXT LOCATION
	INX	H
	SHLD	RADD		; SAVE POINTER
	DCR	C		; COUNT DOWN
	JNZ	BS2		; LOOP THRU TABLE
	MOV	A,B
	ORA	A		; TEST FLAG
	JNZ	BSORT		; IF PERMUTATION, TRY AGAIN
	RET
;
;
; --- FIND OPEN POSITION IN SPARE TRACK TABLE ---
;	    ( AND INIT REST OF TABLE )
FINDSPR:
	LXI	H,BUFF+512-64+1	; POINT TO MSB OF FIRST TABLE VALUE
	LDA	NSPR
	MOV	C,A		; SET TABLE LENGTH
FNDS1:	MOV	A,M		; GET VALUE
	CPI	70H		; IS IT A VALID TRACK #
	JNC	FNDS2		; FOUND OPEN POSITION
	INX	H		; YES, SO KEEP SEARCHING
	INX	H
	DCR	C
	JNZ	FNDS1
	STC		; SET ERROR CONDITION
	RET
FNDS2:	DCX	H	; POINT BACK TO START OF WORD
	PUSH	H	; SAVE POINTER
	INR	C	; THERE ARE REALLY 8 POSITIONS
	LXI	D,-1	; INIT WORD
FNDS3:	CALL	PTDE	; INIT TABLE ENTRY
	DCR	C	; COUNT DOWN TO END OF TABLE
	JNZ	FNDS3
	POP	H	; GET INSERT POINTER BACK
	RET
;
; --- COPY REV B PART OF TABLE TO NEW REV H POSITION ---
;
CPYO2N:	LXI	H,BUFF		; POINT TO SOURCE
	LXI	D,BUFF+512-64	; POINT TO DESTINATION
	MVI	C,16		; # OF BYTES TO COPY
	JMP	MOVE		; DO IT
;
; --- COPY REB B PART OF SPARE TRK TABLE BACK FROM REV H TABLE ---
;
CPYN2O:	LXI	H,BUFF+512-64	; POINT TO SOURCE
	LXI	D,BUFF		; POINT TO DESTINATION
	MVI	C,16		; # OF BYTES TO COPY
	JMP	MOVE
;
; --- EDIT INTERLEAVE VALUE ---
;
EDINTL:	CALL	DINTL	; DISPLAY OLD VALUE
EDI1:	LXI	D,INTMSG1 ; ASK FOR NEW VALUE
	CALL	PTMSG
	CALL	CONNC	; GET FIRST CHAR.
	CPI	CR	; IS IT A CR
	JZ	EDI2	; YES, SO USE CURRENT VERSION
	LXI	H,0	; ZERO CONVERSION BUFFER
	CALL	IN2	; ENTER GET REMAINDER OF NUMBER
	JC	EDI1	; IF ERROR
	PUSH	H
	LXI	D,19	; MAX VALUE
	CALL	SUBDE
	POP	H
	JNC	EDI1	; IF TOO LARGE
	MOV	A,L
	STA	BUFF+16	; UPDATE VALUE
MPCHG:	MVI	A,1
	STA	CFLG	; NOTIFY OF CHANGE
	JMP	MAP1	; BACK TO MENU
EDI2:	CALL	DINTL1	; PRINT CURRENT VALUE
	JMP	MAP1	; AND BACK TO MENU
;
; --- EDIT VDO TABLE ---
;
EDVDO:	LXI	D,VD1MSG ; EXPLAIN TABLE
	CALL	PTMSG
	CALL	DVDO	; DISPLAY CURRENT VDO TABLE
	MVI	A,1
	STA	CTR	; SET LENGTH
	LXI	H,BUFF+18 ; POINT TO START OF TABLE
	PUSH	H
EDV1:	LXI	D,VD2MSG
	CALL	PTMSG
	LDA	CTR	; GET COUNTER
	CALL	DECBT	; PRINT AS PART OF PROMPT
	LXI	D,VD3MSG
	CALL	PTMSG
	CALL	CONNC	; GET FIRST CHAR.
	CPI	'-'
	JZ	EDV3	; IF NULL OUT
	CPI	CR
	JZ	EDV4	; IF USE OLD VALUE
	LXI	H,0	; SET CONVERSION BUFFER
	CALL	IN2	; ENTER DECIMAL INPUT ROUTINE
	JC	EDV1	; IF ERROR
	XCHG		; GET INTO (D,E)
	POP	H	; GET TABLE POINTER
EDV2:	CALL	PTDE	; SAVE NEW VALUE IN TABLE
	PUSH	H	; SAVE NEW POINTER
	MVI	A,1
	STA	CFLG	; NOTIFY OF CHANGE
EDV2X:	LXI	H,CTR	; POINT TO COUNTER
	INR	M
	MOV	A,M
	CPI	7+1	; WAS THIS THE LAST ENTRY?
	JNZ	EDV1	; NO, SO CONTINUE
	POP	H	; CLEAR STACK
	CALL	PCRLF
	JMP	MAP1	; BACK TO MENU
;
EDV3:	CALL	COUT	; ECHO CHAR
	POP	H
	LXI	D,-1	; CHAR. TO DISABLE ENTRY
	JMP	EDV2	; PUT IN TABLE AND CONTINUE
;
EDV4:	POP	H
	CALL	GTDE	; GET TABLE ENTRY
	PUSH	H
	XCHG
	MOV	A,L
	ORA	H
	INR	A
	JZ	EDV5	; IF VALUE WAS -1
	CALL	DECOUT	; PRINT OUT DEFAULT VALUE
	JMP	EDV2X	; AND CONTINUE
EDV5:	MVI	A,4
	CALL	NSPACE
	MVI	C,'-'	; SHOW -1 WITH '-'
	CALL 	COUT
	JMP	EDV2X	; AND CONTINUE
;
; --- DISPLAY SPARED TRACK TABLE ---
;
DSPARE:	LXI	D,DSPMSG
	CALL	PTMSG
	LDA	NSPR
	STA	CTR		; SET COUNTER
	LXI	H,BUFF+512-64	; POINT TO START OF TABLE
DSP1:	CALL	GTDE		; GET ENTRY
	PUSH	H
	PUSH	D
	XCHG
	LXI	D,7000H
	CALL	SUBDE	; IS NUMBER TOO BIG TO MATTER?
	JNC	DSP2	; YES, SO IT IS REALLY NOT SPARED
	MVI	A,11
	CALL	NSPACE	; SPACE CURSOR OVER
	POP	H
	PUSH	H
	CALL	DECOUT	; PRINT OUT VALUE
	CALL	PCRLF
	LXI	H,CTR
	DCR	M	; COUNT DOWN ENTRYS
	POP	D
	POP	H
	JNZ	DSP1	; LOOP UNTIL DONE
	RET
;
DSP2:	POP	D
	POP	H
	LDA	CTR
	MOV	C,A
	LDA	NSPR
	CMP	C	; IS IT THE FIRST POSITION?
	RNZ		; NO, SO JUST RETURN
	LXI	D,DSP1MSG
	JMP	PTMSG	; 'NO TRACKS SPARED'
;
; --- DISPLAY VDO TABLE ---
;
DVDO:	LXI	D,DV1MSG
	CALL	PTMSG
	MVI	A,1
	STA	CTR	; SET COUNTER
	LXI	H,BUFF+18 ; POINT TO TABLE
DVD1:	CALL	GTDE
	PUSH	H
	PUSH	D
	XCHG
	MOV	A,L
	ANA	H	; V2.4 BUG FIX  ( WAS   ORA  H )
	INR	A	; WAS VALUE (-1)
	JZ	DVD2	; YES, SO SKIP OVER IT
	MVI	A,8
	CALL	NSPACE	; SPACE CURSOR OVER
	LDA	CTR	; GET DRIVE COUNTER
	CALL	DECBT	; PRINT IT OUT
	MVI	A,3
	CALL	NSPACE
	POP	H
	PUSH	H
	CALL	DECOUT	; PRINT OUT TABLE ENTRY
	CALL	PCRLF
DVD2:	LXI	H,CTR
	INR	M
	MOV	A,M
	CPI	7+1	; IS IT THE LAST PASS?
	POP	D
	POP	H
	JNZ	DVD1	; NO, KEEP GOING
	RET
;
; --- DISPLAY INTERLEAVING ---
;
DINTL:	LXI	D,DINMSG
	CALL	PTMSG
DINTL1:	LDA	BUFF+16		; GET VALUE
	CALL	DECBT		; SHOW IT
	JMP	PCRLF		; CRLF AND RETURN
;
; --- CONSTELLATION PARAMETERS MENU ---
;
CONSTL:	CALL	INITX	; RE-SYNC DRIVE AND FIND TYPE
	CPI	8FH	; IS IT A "REV A" DRIVE?
	JNZ	REVA	; YES, SO EXIT
	CALL	BSTAT	; GET REV B STATUS STRING
	JC	MN1	; IF ERROR, BACK TO MENU
	MVI	A,3	; SET TO GET BLOCK 3
	STA	DADD
	MVI	A,32H	; SET READ COMMAND
	STA	RWCOM
	CALL	RWCBLK	; READ IN CONTROLLER CODE BLOCK
	XRA	A
	STA	CFLG	; CLEAR BLOCK UPDATE FLAG
			;  ( SET IT IF IT IS CHANGED)
CONL1:	LXI	D,CNMSG1 ; POINT TO CONST. SUB MENU
	CALL	PTMSG	; PRINT IT OUT
	LXI	H,CNTAB	; POINT TO OPTION TABLE
	JMP	DOMNU	; VECTOR TO CHOSEN OPTION
;
CNTAB	EQU	$
	DB	(CNTBE-$-1)/3	; # OF COMMANDS
	DB	'M'
	DW	EDMUX
	DB	'P'
	DW	EDPOL
	DB	'E'
	DW	EXCON
CNTBE	EQU	$
;
; --- EXIT CONSTELLATION PARAM. EDIT ---
;
EXCON:	MVI	A,3		; SET BLOCK #
	STA	CBLK
	JMP	EXUD		; OPTIONALLY WRITE BLOCK BACK
;
; --- EDIT MUX TABLE ---
;
EDMUX:	CALL	DMUX		; DISPLAY MUX TABLE
	LXI	D,MX0MSG
	CALL	PTMSG		; 'CHANGE ?'
	CALL	YES
	JNZ	MX7		; NO, SO RETURN
	LXI	D,MX1MSG
	CALL	PTMSG		; PRINT HEADING
	LXI	H,BUFF		; POINT TO START OF MUX TABLE
	MVI	A,1
	STA	CTR		; SET SLOT COUNTER
	PUSH	H
MX1:	LXI	D,MX2MSG
	CALL	PTMSG
	LDA	CTR
	CALL	DECBT		; PROMPT WITH SLOT #
	LXI	D,MX3MSG
	CALL	PTMSG
MX2:	CALL	CONNC		; GET CHAR.
	CPI	CR		; WAS IT A CR?
	JZ	MX4		; YES, SO PRINT DEFAULT
	MVI	B,4		; SET # OF VALID CHOICES
	LXI	H,MXTAB+1	; POINT TO CONVERSION TABLE
MX3:	CMP	M		; IS THIS THE INPUT CHAR. ?
	JZ	MX5		; YES, CONTINUE...
	INX	H		; SPACE OVER TO NEXT LOCATION
	INX	H
	DCR	B
	JNZ	MX3		; TEST FOR VALID CHOICES
	JMP	MX2		; NO MATCH, SO TRY AGAIN
MX4:	POP	H		; IF DEFAULT, GET POINTER
	MOV	A,M
	CALL	MXPRT		; PRINT IT OUT
	JMP	MX6		; PROCEED TO NEXT SLOT
;
MX5:	DCX	H
	MOV	A,M		; IF MATCH, GET TABLE CHAR.
	POP	H
	MOV	M,A		; AND SAVE IN TABLE
	CALL	COUT		; ECHO INPUT CHAR.
	MVI	A,1
	STA	CFLG		; INDICATE CHANGE
MX6:	INX	H		; POINT TO NEXT TABLE POSITION
	PUSH	H
	LXI	H,CTR
	INR	M		; COUNT UP SLOT #
	MOV	A,M
	CPI	8+1		; DONE YET?
	JNZ	MX1		; NO, GET NEXT ONE
	POP	H		; CLEAR STACK
MX7:	CALL	PCRLF
	JMP	CONL1		; BACK TO MENU
;
; --- EDIT POLLING PARAMETERS ---
;
EDPOL:	CALL	DPOL		; SHOW CURRENT VALUES
	LXI	D,P1MSG
	CALL	PTMSG		; CHANGE ANY?
	CALL	YES
	JNZ	CONL1		; NO, BACK MENU
	CALL	PCRLF
	LXI	H,BUFF+8	; POINT TO TABLE
	MVI	A,1		; SET COUNTER
	STA	CTR
	PUSH	H
EDP1:	LXI	D,P2MSG
	CALL	PTMSG
	LDA	CTR
	CALL	DECBT		; PROMPT WITH #
	LXI	D,P3MSG
	CALL	PTMSG
	CALL	CONNC		; GET FIRST CHAR
	CPI	CR
	JZ	EDP4		; USE DEFAULT
	LXI	H,0
	CALL	IN2		; GET THE REMAINING CHARS.
	JC	EDP1		; IF INPUT ERROR
	MOV	A,H
	ORA	A
	JNZ	EDP1		; ERROR IF TOO BIG
	MOV	A,L
	POP	H
	MOV	M,A		; SAVE NEW VALUE
	INX	H
	MVI	A,1
	STA	CFLG		; NOTE CHANGE
EDP2:	PUSH	H
	LXI	H,CTR
	INR	M
	MOV	A,M
	CPI	4+1		; DONE YET?
	JNZ	EDP1		; NO, SO CONTINUE
	POP	H		; CLEAR STACK
	CALL	PCRLF
	JMP	CONL1
;
EDP4:	POP	H		; POINT TO TABLE LOC.
	MOV	A,M
	INX	H
	CALL	DECBT		; PRINT OUT DEFAULT
	JMP	EDP2		; CONTINUE
;
; --- DISPLAY POLLING PARAMETERS ---
;
DPOL:	LXI	D,P4MSG
	CALL	PTMSG
	MVI	C,4		; SET # OF PARAMS.
	LXI	H,BUFF+8	; POINT TO START OF DATA
DPO1:	MVI	A,11
	CALL	NSPACE
	MOV	A,M
	CALL	DECBT		; PRINT ONE OUT
	PUSH	H
	PUSH	B
	CALL	PCRLF
	POP	B
	POP	H
	INX	H
	DCR	C
	JNZ	DPO1		; LOOP UNTIL DONE
	JMP	PCRLF
;
; --- DISPLAY MUX TABLE ---
;
DMUX:	LXI	D,DX1MSG
	CALL	PTMSG
	LXI	D,4		; SET COUNTER
DMX1:	PUSH	D
	MVI	A,14
	CALL	NSPACE
	LXI	H,BUFF+8
	CALL	SUBDE		; POINT TO TABLE
	MOV	A,M		; GET VALUE
	CALL	MXPRT		; PRINT ITS SYMBOL
	MVI	A,6
	CALL	NSPACE
	LXI	H,BUFF-1
	DAD	D
	MOV	A,M		; GET NEXT VALUE
	CALL	MXPRT
	CALL	PCRLF
	POP	D
	DCR	E		; COUNT DOWN
	JNZ	DMX1		; LOOP UNTIL DONE
	LXI	D,DX2MSG
	JMP	PTMSG
;
; --- PRINT SYMBOL FOR MUX TABLE VALUE ---
;
MXPRT:	PUSH	H
	LXI	H,MXTAB		; POINT TO CONVERSION TABLE
	MVI	B,4		; SET TABLE SIZE
	MVI	C,'*'		; IF NO MATCH, USE '*'
MXP1:	CMP	M		; MATCH?
	INX	H
	JZ	MXP2		; YES, SO PRINT SYMBOL
	INX	H
	DCR	B
	JNZ	MXP1		; LOOP THRU TABLE
	JMP 	MXP3		; USE SPECIAL SYMBOL IF NO MATCH
MXP2:	MOV	C,M		; GET SYMBOL
MXP3:	CALL	COUT		; PRINT IT OUT
	POP	H
	RET
;
; --- CONVERSION TABLE FOR MUX TABLE ---
;
MXTAB	EQU	$
	DB	0,'-'
	DB	1,'M'
	DB	2,'L'
	DB	128,'C'
;
; --- PARK REV H DRIVE HEADS ---
;	-- 2.5
;
PARK:	CALL	INITX		; INIT. DRIVE AND READ VERSION #
	CPI	8FH
	JNZ	NREVH		; IF NOT REV H
	CALL	BSTAT		; IF REV H OR B, GET STATUS DATA
	JC	RDC2		; IF ERROR, BACK TO MENU
	CALL	PCRLF
	LDA	NSPR		; GET # OF SPARE TRKS SET IN BSTAT
	CPI	31		; IS DRIVE A REV H?
	JNZ	NREVH		; NO, SO EXIT WITH MESSAGE
;
	MVI	A,UCOM		; GET UNIV. COMMAND
	CALL	WAITO		; SEND IT TO CONTROLLER
	LDA	DRIVE		; GET DRIVE #
	CALL	WAITO		; SEND IT TO CONTROLLER
	LXI	H,PKBUF		; POINT TO START OF "PARK DATA"
	LXI	B,512		; SIZE OF DATA FOR UNIV. COMMAND
PKLP:	CALL	WLP		; SEND BLOCK TO DRIVE
	JC	MN1		; IF ERROR
;
	LXI	D,PKKMSG	; POINT TO MESSAGE ( " HEADS PARKED ")
	JMP	MN0		; PRINT IT OUT AND RESTART MENU
;
NREVH:	LXI	D,PKMSG		; MESSAGE IF NOT REV H
	JMP	MN0
;
; ------ SUBROUTINES & DATA ------
;
; --- VERIFY COMMAND ERROR LISTER ---
;
VLST:	LXI	H,BUFF+1	; POINT TO DATA
	SHLD	BFPTR		; SET BUFFER POINTER
	DCX	H
	MOV	A,M		; GET # OF ERROR BYTES
	ORA	A		; TEST IF NO ERRORS
	LXI	D,MSG8		; POINT TO MESSAGE
	JZ	MN0		; ISSUE MESSAGE AND RESTART
	CPI	255		; TEST IF TOO MANY ERRORS
	LXI	D,MSG9
	JZ	MN0		; IF TOO MANY ERRORS
	RRC			; DIVIDE BY 4
	RRC
	STA	CTR		; SAVE # OF ERROR LINES
	LXI	D,MSG7
	CALL	PTMSG		; PRINT ERROR TABLE HEADING
ERRLST1: MVI	A,2	; SET FOR 2 SPACES
	CALL	NSPACE	; PRINT (A) SPACES
	CALL	GTBYT	; GET CHAR. FROM BUFFER
	MOV	C,A	; SAVE IT
	MVI	B,0
	PUSH	B
	CALL	DECBT	; PRINT IT OUT
	MVI	A,5	; SET FOR 5 SPACES
	CALL	NSPACE
	CALL	GTBYT	; GET LOW BYTE OF CYLINDER #
	MOV	L,A
	CALL	GTBYT	; GET UPPER BYTE OF CYLINDER #
	MOV	H,A
	PUSH	H	; SAVE IT
	CALL	DECOUT	; PRINT IT OUT IN DECIMAL
	MVI	A,5	; SET FOR 5 SPACES
	CALL	NSPACE
	CALL	GTBYT	; GET TRACK SECTOR #
	CALL	DECBT	; OUTPUT IN DECIMAL
	MVI	A,3
	CALL	NSPACE
	POP	H
	LDA	STATBF+34 ; GET # OF HEADS
	CALL	MULT	; COMPUTE: (CYL#)*(#HEADS)
	POP	B	; GET SURFACE #
	DAD	B	; (H,L)=(CYL#)*(#HEADS)+(SURFACE #)
	CALL	DECOUT	; PRINT IT OUT
	CALL	PCRLF
	LXI	H,CTR	; POINT TO COUNTER
	DCR	M
	JNZ	ERRLST1	; LOOP UNTIL DONE
	LXI	D,MSG7X
	CALL	PTMSG	; 'LIST AGAIN?'
	CALL	YES
	JZ	VLST	; YES, SO DO IT
	JMP	MN1	; NO, SO BACK TO MENU
;
GTBYT:	PUSH	H
	LHLD	BFPTR	; GET BUFFER POINTER
	MOV	A,M	; GET BYTE
	INX	H	; INCREMENT POINTER
	SHLD	BFPTR	; SAVE POINTER
	POP	H
	RET
;
;
KTST:	CALL	CONST	; TEST CONSOLE STATUS
	ORA	A
	RZ		; RETURN IF NO KEY HAS BEEN HIT
	CALL	CONIN	; OTHERWISE GET THE CHAR.
	PUSH	PSW	; SAVE CHAR.
	LHLD	MSGPTR	; GET POINTER TO MESSAGE
	XCHG
	CALL	PTMSG	; PRINT IT OUT
	POP	PSW	; GET CHAR. BACK
	RET
;
;  --- ROUTINE TO PAUSE AND WAIT FOR <RET> ---
;
CRTST:	LXI	D,CRMSG
	CALL	PTMSG
CRT1:	CALL	CONNC	; GET CHAR.
	CPI	CR
	JNZ	CRT1	; WAIT FOR CR
	JMP	PCRLF
;
RWSEC:	LDA	RWCOM	; GET READ/ WRITE COMMAND
	CALL	WAITO	; WAIT AND SEND IT
	LDA	DRIVE	; GET DRIVE # AND HIGH ADD. NIBBLE
	CALL	WAITO
	LDA	DADD	; GET LOW BYTE OF DISC ADDRESS
	CALL	WAITO
	LDA	DADD+1	; GET UPPER BYTE OF DISC ADDRESS
	CALL	WAITO
RWSC1:	LDA	RWCOM	; GET COMMAND AGAIN
	ANI	1	; LOOK AT BIT 0
	JNZ	WTSEC	; MUST BE 'WRITE' TYPE COMMAND
RWS1:	CALL	WERR	; NO, SO ASSUME READ AND GET ERROR CODE
	RC		; RETURN IF ERROR
RSEC:	LHLD	SLEN	; GET SECTOR LENGTH
	MOV	C,L	;  INTO (B,C)
	MOV	B,H
	LHLD	RADD	; GET 'RAM' ADDRESS
RLP:	CALL	WAITI	; 2.2 - USE WAITI ROUTINE FOR RLP
	MOV	M,A	; SAVE IT IN MEMORY
	INX	H	;
	DCX	B	; DEC COUNTER
	MOV	A,B	; SET UP FOR TEST OF COUNT = 0
	ORA	C	; TEST
	JNZ	RLP	; IF NOT, LOOP
	RET		;
;
;
WTSEC:	LHLD	SLEN	; GET SECTOR LENGTH
	MOV	C,L	;  INTO (B,C)
	MOV	B,H
	LHLD	RADD	; GET 'RAM' ADDRESS
WLP:	MOV	A,M	; PUT DATA IN ACC
	CALL	WAITO	; OUTPUT DATA WHEN READY
	INX	H	; INCREMENT BUF POINTER
	DCX	B	; DECREMENT COUNTER
	MOV	A,B	; SET UP FOR COUNTER = 0 TEST
	ORA	C	; TEST
	JNZ	WLP	; IF NOT, LOOP

WERR:	CALL	TURN	; TURN AROUND BUSS
WERR1:	CALL	WAITI	; WAIT FOR ERROR BYTE
WERR2:	MOV	B,A	; SAVE BYTE
	ANI	80H	; LOOK FOR FATAL ERRORS
	RZ		; OK, SO RETURN
	PUSH	B	; SAVE ERROR
	LXI	D,MSGE	; ERROR, SO ISSUE MESSAGE
	CALL	PTMSG
	POP	PSW	; GET ERROR BYTE BACK IN ACC
	CALL	HEXOT	; OUTPUT IN HEX
	LXI	D,MSGE1
	CALL	PTMSG
;
;   --- CANNOT AFFORD TO EXIT IF ERROR, SO TRY TO FIX IT ---
;
	CALL	INIT	; RE-SYNCHRONIZE CONTROLLER
	STC		; SET CARRY TO INDICATE ERROR
	RET
;
;
INITX:	CALL	INIT	; DO INIT THEN DO VCHK
;
; --- TEST DRIVE TYPE AND REV A CODE VERSION # ---
;
VCHK:	MVI	A,0	; GET A ZERO
	CALL	WAITO	; SEND IT
	CALL	TURN	; WAIT FOR ACCEPTANCE
	CALL	WAITI	; GET ANSWER
	STA	SRTN
	MOV	B,A	; SAVE IT
	ANI	0F0H	; MASK OUT DRIVE # AND TEST VERSION #
	MOV	A,B	; GET CODE BACK
	RNZ		; NOT VERS. 0   SO RETURN
	LDA	RWCOM	; GET READ/ WRITE COMMAND
	ANI	0FH	; MASK TO REV 0 CONTROLLER CODE VERSION
	STA	RWCOM	; RESAVE IT
	MOV	A,B	; GET CODE BACK
	RET
;
; --- SET REV A EQUIV. STATUS INFORMATION ---
;
REVAFIX: LDA	SRTN	; GET RETURN CODE
	CPI	8FH	; REV B DRIVE ?
	RZ		; YES, SO EXIT
	PUSH	PSW
	LXI	H,REVADTA ; POINT TO REV A DATA
	LXI	D,STATBF+33 ; SET DESTINATION
	MVI	C,7	; LENGTH OF TABLE TO MOVE
	CALL	MOVE	; DO IT
	POP	PSW	; RESTORE RTN CODE
	RET
;
; --- BLOCK READ/WRITE ROUTINE ---
;
RWBLK:	LDA	NSEC	; GET # OF SECTORS
	ORA	A	; IS IT ZERO?
	RZ		; YES, ALL DONE
RWBK1:	CALL	RWSEC	; READ/WRITE ONE SECTOR
	RC		; EXIT IF ERROR
	LHLD	SLEN	; GET SECTOR LENGTH
	XCHG		;  INTO (D,E)
	LHLD	RADD	; GET 'RAM' ADDRESS
	DAD	D	; POINT TO NEXT ADDRESS
	SHLD	RADD
	LHLD	DADD	; GET DISC ADDRESS
	INX	H	; POINT TO NEXT SECTOR
	SHLD	DADD
	LXI	H,NSEC	; POINT TO SECTOR COUNTER
	DCR	M	; COUNT DOWN
	JNZ	RWBK1	; LOOP UNTIL DONE
	RET
;
; --- READ/WRITE ONE CONTROLLER CODE BLOCK (REV B DRIVE ) ---
;
RWCBLK:	CALL	PREP1	; GO INTO PREP MODE
	JC	UDBX	; IF ERROR
	LXI	H,BUFF	; POINT TO RAM
	SHLD	RADD
	LXI	H,512	; SET SECTOR SIZE
	SHLD	SLEN
	LDA	RWCOM	; GET COMMAND
	CALL	WAITO	; SEND IT
	LDA	DADD	; GET SECTOR ADDRESS
	CALL	WAITO
	CALL	RWSC1	; CONTINUE WITH NORMAL R/W ROUTINE
	JC	UDBX	; IF ERROR
	CALL	EXPREP	; EXIT PREP MODE
	JC	Q1	; IF ERROR
	RET

;
; --- GET RETURNED DATA BLOCK BACK FROM DRIVE ---
;	(THIS ROUTINE IS INDEPENDENT OF THE)
;	(LENGTH OF THE RETURNED DATA BLOCK)
;
GETBLK:	MVI	B,6	; SET DELAY COUNT
	CALL	TURN	; WAIT FOR BUSS TO TURN AROUND
GTBLK1:	CALL	WAITI	; GET ERROR CODE
	STA	RTNCD	; SAVE IT
	LHLD	RADD	; GET POINTER TO BUFFER
			; 2.2 - USE GTBLK TO READ IN BYTES
	CALL	GTBLK	; GET BYTES TILL BUS TURNS AROUND
	POP	H	; GET LENGTH OFF OF STACK
	SHLD	RTLEN	; SAVE RETURN LENGTH
	LDA	RTNCD	; GET ERROR CODE BACK
	MOV	C,A
	ANI	80H	; TEST ERROR STATUS
	MOV	A,C	; GET ACTUAL RTN CODE BACK
	RET
;
; --- COPY CODE FROM (H,L) TO (D,E) FOR (C) BYTES ---
;
MOVE:	MOV	A,M
	STAX	D
	INX	H
	INX	D
	DCR	C
	JNZ	MOVE
	RET
;
;
;
; --- READ IN CODE FROM CP/M DISC ---
;
;	2.3 -	ADD CODE TO ALLOW READ/WRITE OF CONTROLLER
;		CODE IF IT WILL NOT FIT IN MEMORY
;
RDCPM:	LDA	EOFLG	; GET END OF FILE FLAG
	ORA	A	; CLEAR CARRY & SET Z FLAG IF 0
	RZ		; RETURN IF END OF FILE
	LXI	H,BUFF	; POINT TO BUFFER
	SHLD	RADD	; SAVE IT
RD0:	LXI	H,NSEC	; POINT TO SECTOR COUNTER
	MVI	M, 4	; SET SECTOR COUNT
RD1:	LHLD	RADD	; GET BUFFER POINTER
	XCHG		; INTO (D,E)
	MVI	C,SDMA	; CODE TO SET DMA ADDRESS
	CALL	BDOS	; SET DMA ADDRESS
	LXI	D,FCB	; POINT TO FCB
	MVI	C,READ	; BDOS READ CODE
	CALL	BDOS	; READ IN ONE SECTOR (128 BYTES)
	ORA	A
	JNZ	RD2	; IF NON ZERO RETURN CODE
;			  UPDATE POINTERS
	LHLD	RADD	; GET POINTER
	LXI	D,128
	DAD	D
	SHLD	RADD	; UPDATE IT
	LXI	H,NSEC	; POINT TO SECTOR COUNTER
	DCR	M	; DEC COUNTER
	JNZ	RD1	; IF NOT 0, CONTINUE
;			  TEST REMAINING MEM
	LHLD	RADD	; GET NEXT RAM ADDR
	LXI	D,512
	DAD	D	; POINT TO END OF NEXT LOAD
	XCHG
	LHLD	TOP	; GET TOP OF RAM BUFFER
	CALL	SUBDE
	JC	TOBIG	; IF NEXT LOAD WOULD OVERLAY BDOS
	JMP	RD0	; LOOP UNTIL DONE
;
RD2:	DCR	A	; TEST RETURN CODE
	JNZ	RDE	; IF ERROR ,REPORT AND EXIT
	XRA	A	; 0 ACC
	STA	EOFLG	; SET END OF FILE FLAG
	ORI	1	; CLEAR CARRY & Z FLAG
	RET		;
;
RDE:	LXI	D,MSGE2	; OTHERWISE GET ERROR MESSAGE
	CALL	PTMSG	; PRINT IT OUT
	STC		; SET ERROR CONDITION
	RET
;
TOBIG:	MVI	A, 1	;
	STA	WFLG	; SET WARM BOOT FLAG
	LXI	D,BIGMSG
	CALL	PTMSG	; PRINT MESSAGE
	CALL	YES	; OK TO R/W CONTROLLER CODE
	JNZ	MN1	; IF NOT,  BACK TO MENU
	ORI	1	; CLEAR C & Z FLAG
	RET		;
;
; --- GET ASCII STRING FROM CONSOLE AND SAVE IN BUFFER ---
;
;
GTNAM:
GTN2:	LHLD	MSGPTR	; GET POINTER TO PROMPT MESSAGE
	XCHG		; INTO (D,E)
	CALL	PTMSG	; ASK FOR NAME
	LXI	D,TXBUF	; POINT TO INPUT BUFFER
	MVI	C,RDBUF	; GET BUFFER READ COMMAND
	CALL	BDOS	; INPUT TEXT STREAM
	LXI	H,TXBUF+1 ; POINT TO CHAR. COUNTER
	MOV	A,M	; GET IT
	INX	H
	ORA	A	; IS IT ZERO?
	JZ	GTN2	; YES, SO TRY AGAIN
	XCHG		; SAVE POINTER IN (D,E)
	MOV	L,A	; GET LENGTH IN (H,L)
	MVI	H,0
	DAD	D	; POINT TO POSITION AT END OF STRING
	MVI	M,0	; PUT IN A NULL (STRING TERMINATOR)
	RET
;
; --- SETUP CP/M FILE CONTROL BLOCK ---
;
MAKFCB:	XRA	A
	LXI	H,FCB	; POINT TO START OF FCB
	MOV	M,A	; RESET AUTO SELECT BYTE
	STA	FCB+12	; CLEAR EXTENT COUNTER
	STA	FCB+32	; CLEAR NEXT RECORD COUNTER
	INX	H
	PUSH	H	; SAVE POINTER
	MVI	A,11	; GET LENGTH OF NAME BUFFER
MAK1:	MVI	M,' '	; CLEAR OUT NAME IN FCB
	INX	H
	DCR	A
	JNZ	MAK1
	LXI	H,TXBUF+2 ; POINT TO NAME IN CHAR. BUFFER
	POP	D	; GET POINTER TO DESTINATION
	MVI	B,8	; SET LENGTH OF NAME
MAK2:	CALL	GT$CONV	; GET CHAR. AND CONV. TO UPPER CASE
	RC		; RETURN IF AT END OF BUFFER
	CPI	' '	; IS IT A SPACE
	JZ	MAK2	; YES, LOOP UNTIL FIRST NON-BLANK CHAR.
	MOV	A,M	; GET NEXT CHAR.
	DCX	H	; POINT BACK TO NON-BLANK CHAR.
	CPI	':'	; IS DRIVE SELECT SPECIFIED?
	JNZ	MAK4	; NO, SO CONTINUE
	MOV	A,M	; GET DRIVE DESIGNATOR
	SUI	'A'	; REMOVE ASCII BIAS
	RC		; RETURN IF INVALID DRIVE TYPE
	INR	A	; INCREMENT FOR AUTO-SELECT
	STA	FCB	; SET AUTO-SELECT BYTE
	INX	H	; SET POINTER BACK
	INX	H
MAK4:	CALL	GT$CONV	; GET NEXT CHAR. AND CONVERT TO UPPER CASE
	JC	MAKOK	; IF END OF INPUT STRING
	JZ	MAK6	; IF "."
	CALL	CHRTST	; TEST FOR OTHER INVALID CHARS.
	RC		; IF ILLEGAL CHAR.
	JZ	MAKOK	; IF SPACE, ASSUME END OF INPUT NAME
	MOV	C,A	; SAVE OUTPUT
	CALL	PTCHR	; OTHERWISE, SAVE IN FCB
	JNC	MAK4	; LOOP TO SAVE THE REMAINING 8 CHARS.
MAK6:	LXI	D,FCB+9	; SET PUT POINTER TO FILE TYPE PART
	MVI	B,3	; LENGTH OF FILE TYPE
MAK7:	CALL	GT$CONV	; GET CHAR.
	JC	MAKOK	; IF NO MORE CHARS.
	STC
	RZ		; IF "."
	CALL	CHRTST	; TEST FOR OTHER INVALID CHARS.
	RC		; IF ILLEGAL CHAR.
	JZ	MAKOK	; IF SPACE, ASSUME END OF INPUT
	MOV	C,A	; SAVE FOR OUTPUT
	CALL	PTCHR	; OTHERWISE SAVE IN FCB
	JNC	MAK7	; LOOP TO SETUP REST OF FILE TYPE
MAKOK:	LDA	FCB+1	; GET FIRST CHAR. OF FILE NAME
	CPI	' '	; SEE IF SPACE
	STC		; SET CARRY FOR ERROR EXIT
	RZ		; ERROR IF STILL SPACE
	ORA	A	; CLEAR CARRY
	RET
;
GT$CONV: CALL	GTCHR	; GET CHAR.
	RC		; IF END OF INPUT
	CPI	61H	; IS IT UPPER CASE
	JC	GTC1	; YES, SO LEAVE ALONE
	CPI	7BH	; IS IT ABOVE STD LOWER CASE
	JNC	GTC1	; YES, SO LEAVE ALONE
	ANI	5FH	; MUST BE LOWER CASE, SO CONVERT
GTC1:	CPI	'.'	; TEST FOR '.'
	RZ
	ORA	A	; CLEAR CARRY
	RET
;
; --- TEST FOR ILLEGAL CHARACTERS IN FILE NAME ---
;
CHRTST:	CALL	CTST	; TEST IF CHAR. IS LEGAL
	STC
	RZ		; RETURN WITH CARRY SET IF BAD CHAR.
	CPI	' '	; TEST FOR SPACE
	RET
;
CTST:	CPI	':'
	RZ
	CPI	'$'
	RZ
	CPI	'?'
	RZ
	CPI	'*'
	RZ
	CPI	';'
	RZ
	CPI	'<'
	RZ
	CPI	'>'
	RET
;
GTCHR:	MOV	A,M	; GET CHAR. FORM TEXT BUFFER
	ORA	A	; IS IT A NULL (TERMINATOR)
	STC
	RZ		; YES, RETURN WITH CARRY SET
	INX	H	; POINT TO NEXT CHAR.
	ORA	A	; CLEAR CARRY
	RET
;
PTCHR:	MOV	A,B	; GET COUNTER
	ORA	A	; TEST IF ZERO
	STC
	RZ		; YES, RETURN WITH CARRY SET
	MOV	A,C	; GET CHAR.
	STAX	D	; SAVE IN DESTINATION LOCATION
	INX	D	; POINT TO NEXT LOCATION
	DCR	C	; COUNT DOWN
	ORA	A	; CLEAR CARRY
	RET
;
; --- COMPARE MEMORY AT (H,L) TO THAT AT (D,E) FOR (C) BYTES ---
;
COMPARE: LDAX	D	; GET BYTE
	CMP 	M	; COMPARE
	RNZ		; RETURN IF NOT EQUAL
	INX	H	; OTHERWISE INC. POINTERS
	INX	D
	DCR	C	; COUNT DOWN BYTES
	JNZ	COMPARE	; LOOP UNTIL DONE
	RET
;
; --- SUBTRACT : (H,L)=(H,L)-(D,E) ---
;
SUBDE:	MOV	A,L
	SUB	E
	MOV	L,A
	MOV	A,H
	SBB	D
	MOV	H,A
	RET
;
; --- MULTIPLY : (H,L)=(H,L)*(A) ---
;
MULT:	LXI	D,0	; ZERO CONVERSION BUFFER
	XCHG
	MVI	B,8	; SET TO MULTIPLY 8 BITS
ML1:	DAD	H	; SHIFT BUFFER OVER 1
	RAL		; TEST NEXT BIT OF (A)
	JNC	ML2	; IF NOT A 1, ADD IN (D,E)
	DAD	D
ML2:	DCR	B	; COUNT DOWN # OF BITS
	JNZ	ML1	; LOOP UNTIL DONE
	RET
;
; --- COMPARE (H,L) TO (D,E) BY FORMING (H,L)-(D,E) ---
;
COMPDE:	MOV	A,L
	SUB	E
	MOV	A,H
	SBB	D
	RET
;
; --- MESSAGE PRINT ROUTINE---
;     THIS IS USED INSTEAD OF USUAL FUNCTION CODE #9
;     SO THAT THE POINTER TO END OF LIST CAN BE RECOVERED.
;
;
PTMSG:	LDAX	D	; GET CHARACTER
	CPI	'$'	; IS IT END CHAR. ?
	RZ		; YES, EXIT
	CPI	0	; 2.3 - STRIP NULL CHARS
	JZ	SKPC	; IF IT IS THEN SKIP IT
	PUSH	D	; SAVE POINTER
	MOV	E,A	; SAVE FOR OUTPUT
	MVI	C,CHOUT	; CONSOLE OUTPUT CODE
	CALL	BDOS	; OUTPUT CHAR. TO CONSOLE
	POP	D
SKPC:	INX	D
	JMP	PTMSG	; LOOP TO OUTPUT ALL OF LIST
;
; --- PRINT OUT STRING OF SPECIFIED LENGTH ---
;	(D,E) POINT TO STRING
;	(B)   GIVES LENGTH
;
PTSTR:	LDAX	D	; GET CHAR.
	CALL	PRT	; PRINT IT OUT
	INX	D
	DCR	B
	JNZ	PTSTR	; LOOP UNTIL DONE
	RET
;
; --- OUTPUT BYTE IN ACC IN HEX ---
;
HEXOT:	PUSH	PSW	; SAVE BYTE
	RRC		; SHIFT UPPER NIBBLE DOWN
	RRC
	RRC
	RRC
	CALL	HEXB	; OUTPUT UPPER NIBBLE IN HEX
	POP	PSW	; GET BYTE BACK
HEXB:	ANI	0FH	; MASK OFF UPPER NIBBLE
	ADI	'0'	; ADD ASCII BIAS
	CPI	'9'+1	; TEST IF NUMERIC
	JC	PRT	; YES, SO DO IT
	ADI	7	; NO, SO ADD BIAS FOR A-F
PRT:	MOV	C,A	; SETUP FOR OUTPUT
COUT:	PUSH	PSW
	PUSH	H	; BUFFERED CONSOLE OUTPUT
	PUSH	D
	PUSH	B
	MOV	E,C
	MVI	C,CHOUT	; BDOS CHAR. OUTPUT COMMAND
	CALL	BDOS
	POP	B
	POP	D
	POP	H
	POP	PSW
	RET
;
;  --- HEX INPUT ROUTINE ----
;
INHEX:	LXI	H,0	; CLEAR CONVERSION REGISTER
H1:	PUSH	H
	CALL	CONNC	; GET CHAR.
	POP	H
	CPI	' '	; IS IT A SPACE
	JZ	H1	; IGNORE IT
	CPI	CR	; IS IT A CR
	RZ		; YES, SO RETURN
HEX2:	CALL	COUT	; ECHO CHARACTER
	SUI	'0'	; REMOVE ASCII BIAS
	RC
	CPI	'G'-'0'
	CMC
	RC
	CPI	10
	JC	HEX1
	SUI	7	; ADJUST FOR A-F CHARACTERS
	CPI	10
	RC
HEX1:	DAD	H	; SHIFT 16 BIT REGISTER OVER 4 PLACES
	DAD	H
	DAD	H
	DAD	H
	ADD	L	; ADD IN NEW NIBBLE
	MOV	L,A
	JMP	H1
;
; -- TWO BYTE DECIMAL INPUT ROUTINE --
;
INDEC:	LXI	H,0	; CLEAR CONVERSION REGISTER
IN1:	PUSH	H
	CALL	CONNC	; GET CHARACTER
	POP	H
IN2:	CPI	' '	; IS IT A SPACE?
	JZ	IN1	; IGNORE IT
	CPI	CR	; IS IT A CR?
	RZ		; YES, SO RETURN
	CALL	COUT	; ECHO CHAR.
	SUI	'0'	; REMOVE ASCII BIAS
	RC		; RETURN IF ERROR
	CPI	10	; TEST IF TOO BIG
	CMC
	RC		; RETURN IF ERROR
	MOV	E,L	; GET COPY OF (H,L) IN (D,E)
	MOV	D,H
	DAD	H	; MULTIPLY BY 5
	DAD	H
	DAD	D
	DAD	H	; NOW  10 X STARTING VALUE
	MOV	E,A
	MVI	D,0
	DAD	D	; ADD IN NEW UNITS DIGIT
	JMP	IN1	; LOOP FOR MORE
;
; --- OUTPUT (H,L) IN DECIMAL ---
;
DECOUT:	LXI	D,-10000	; SET TO SUBTRACT 10000
	MVI	B,'0'		; SET TO SUPRESS LEADING ZEROS
	CALL	DEC2		; OUTPUT FIRST CHAR.
	LXI	D,-1000		; SET TO SUBTRACT 1000
	CALL	DEC2		; OUTPUT SECOND CHAR.
DEC4:	LXI	D,-100		; SET TO SUBTRACT 100
	CALL	DEC2		; OUTPUT THIRD CHAR.
	LXI	D,-10		; SET TO SUBTRACT 10
	CALL	DEC2		; OUTPUT FORTH CHAR.
	MVI	B,0		; ALLOW LEADING ZERO
	LXI	D,-1		; SET TO SUBTRACT  1
DEC2:	MVI	C,'0'-1		; SET CHAR. COUNT
DEC3:	SHLD	DECBUF		; SAVE REMAINDER
	INR	C		; INC. ASCII CHAR. COUNTER
	DAD	D		; DO SUBTRACTION
	JC	DEC3		; LOOP UNTIL UNDERFLOW
	LHLD	DECBUF		; GET LAST REMAINDER
	MOV	A,C		; GET CHAR. COUNTER
	CMP	B		; TEST FOR ZERO SUPPRESS
	JZ	SPACE		; ISSUE SPACE IF ZERO SUPPRESS IS ON
	MVI	B,0		; CLEAR ZERO SUPPRESS FLAG
	JMP	COUT		; OUTPUT CHAR.
;
; -- OUTPUT BYTE IN DECIMAL --
;
DECBT:	PUSH	H
	PUSH	D
	PUSH	B
	MOV	L,A	; SAVE BYTE IN (H,L)
	MVI	H,0
	MVI	B,'0'	; SET TO SUPRESS LEADING ZEROS
	CALL	DEC4
	POP	B
	POP	D
	POP	H
	RET
;
; -- SPACE PRINTER FUNCTIONS --
;
SPACE:	MVI	A,1	; SET FOR ONE SPACE
;
NSPACE:	PUSH	B
	MOV	B,A	; SAVE # OF SPACES TO OUTPUT
NSP1:	MVI	A,' '	; GET A SPACE
	CALL	PRT	; PRINT IT OUT
	DCR	B	; COUNT DOWN
	JNZ	NSP1	; LOOP UNTIL DONE
	POP	B
	RET
;
; -- YES FUNCTION --
;
YES:	CALL	CONNC	; GET CONSOLE CHAR.
	CPI	'Y'	; IS IT A  Y?
	JZ	YES1
	CPI	'N'	; IS IT A  N?
	JNZ	YES	; IF NEITHER, KEEP TRYING
	INR	A	; SET  N  STATUS
YES1:	PUSH	PSW	; SAVE FLAGS
	CALL	CONOUT	; OUTPUT TO CONSOLE
	POP	PSW	; RESTORE FLAGS
	RET
CONNC:	CALL	CONIN	; GET CHAR. FROM CONSOLE
	MOV	C,A	; SAVE FOR ECHO
	CPI	60H	; IS IT LOWER CASE?
	JC	CON1	; NO, SO CONTINUE
	ANI	5FH	; YES, SO MASK TO UPPER CASE
CON1:	CPI	'C'-40H	; IS IT A CONTROL-C?
	RNZ		; NO, SO RETURN
CTC:	LXI	D,CMSG	; POINT TO CONTROL-C MESSAGE
EXMG:	CALL	PTMSG		; PRINT MESSAGE
EXIT:	LXI	D,CRLF
	CALL	PTMSG		; ISSUE CRLF
	LXI	D,80H		; DMA ADDRESS
	MVI	C,SDMA
	CALL	BDOS		; RESET DMA ADDRESS
	LHLD	SBUF		; GET OLD STACK POINTER
	SPHL			; SET STACK
	LDA	WFLG		; GET OVERLAY FLAG
	ORA	A		; TEST IT
	RZ			; OK, SO BACK TO CP/M
	JMP	0		; IF CP/M OVERLAY, WARM BOOT
;
; --- GET (D,E) FROM (M,M+1) ---
;
GTDE:	MOV	E,M
	INX	H
	MOV	D,M
	INX	H
	RET
;
; --- PUT (D,E) INTO (M,M+1) ---
;
PTDE:	MOV	M,E
	INX	H
	MOV	M,D
	INX	H
	RET
;
; --- SEARCH TABLE FOR MATCH AND GET ASSOC. ADDRESS ---
;	(H,L) POINT TO TABLE TO SEARCH
;	(B)   HAS THE # OF TABLE ELEMENTS
;	(C)   HAS THE BYTE TO MATCH WITH
;
STAB:	MOV	A,M	; GET TABLE VALUE
	INX	H	; POINT TO START OF ADDRESS
	CMP	C	; IS THERE A MATCH?
	JNZ	STB1	; NO, SO CONTINUE
	MOV	E,M	; GET LOWER BYTE OF ADDRESS
	INX	H
	MOV	D,M	; ADDRESS IN (D,E)
	RET
STB1:	INX	H	; SKIP OVER ADDRESS
	INX	H
	DCR	B	; COUNT DOWN COMMANDS
	JNZ	STAB	; LOOP THRU TABLE
	STC		; NO MATCH, SO SET ERROR
	RET
;
; --- INPUT MENU SELECTION AND BRANCH TO SERVICE ROUTINES ---
;
DOMNU:	SHLD	MNUPTR	; SAVE MENU POINTER
DM1:	CALL	CONNC	; GET OPTION
	MOV	C,A	; SAVE FOR ECHO
	LHLD	MNUPTR	; GET MENU POINTER
	MOV	B,M	; SET LENGTH OF SCAN
	INX	H	; POINT TO START OF TABLE
	CALL	STAB	; SCAN THRU TABLE
	JC	DM1	; IF NO MATCH, TRY AGAIN
	PUSH	D	; SAVE VECTOR ON STACK
	CALL	COUT	; ECHO VALID INPUT CHAR.
PCRLF:	LXI	D,CRLF	; ISSUE CRLF
	JMP	PTMSG
;
;
; --- CHECKSUM A BLOCK OF MEMORY ---
;	(H,L)= STARTING ADD
;	(D,E)= LENGTH OF BLOCK
;	  (C)= RUNNING SUM (MUST INITIALLY CLEAR)
;
CKSUM:	MOV	A,M	; GET DATA BYTE
	ADD	C	; ADD IN PREVIOUS SUM
	RRC		; MORE LIKE A CRC
	MOV	C,A	; UPDATE COUNT
	INX	H	; POINT TO NEXT BYTE
	DCX	D
	MOV	A,D
	ORA	E
	JNZ	CKSUM	; LOOP THRU WHOLE BLOCK
	MOV	A,C	; GET SUM BACK
	STA	CKS	; SAVE IT FOR POSSIBLE INSPECTION
	RET
;
; --- ASK FOR AND GET DRIVE # ---
;
GTDRV:	LXI	D,DMSG
	CALL	PTMSG	; ASK FOR DRIVE #
GTDRV1:	CALL	CONNC	; GET CONSOLE CHAR.
	CPI	'1'
	JC	GTDRV1	; IF INVALID, TRY AGAIN
	CPI	'4'+1
	JNC	GTDRV1
	SUI	'0'	; REMOVE ASCII BIAS
	STA	DRIVE	; SAVE IT
GTT1:	CALL	COUT	; ECHO IT
	PUSH	PSW	; SAVE IT
	LXI	D,CRLF
	CALL	PTMSG	; PRINT CRLF
	POP	PSW
	RET
;
;
; --- WRITE OUT DIAGNOSTIC (PREP) CODE BLOCK TO DISC CONT. ---
;		(FOR REV B CONTROLLER)
;
PREP:	CALL	GTDRV	; GET DRIVE #
	LXI	D,CRLF
	CALL	PTMSG
PREP1:	LXI	H,DCODE	; POINT TO CODE BLOCK
	LXI	D,512	; LENGTH OF BLOCK
	MVI	C,0	; CLEAR CHECK COUNT
	CALL	CKSUM	; CHECKSUM THE BLOCK (TO SEE IF VALID)
	CPI	CHKSUM	; IS IT CORRECT? ( # FOR REV 26 CODE)
	JZ	PREP2	; YES, SO PROCEED
	LXI	D,MSG17	; NO, SO SET ERROR MESSAGE
	CALL	PTMSG
	STC		; SET ERROR INDICATOR
	RET
PREP2:	MVI	A,UCOM	; GET UNIV. COMMAND
	CALL	WAITO	; SEND IT TO CONTROLLER
	LDA	DRIVE	; GET DRIVE #
	CALL	WAITO	; SEND IT TO DRIVE
	LXI	H,DCODE	; SET LOCATION OF DIAG. CODE
	LXI	B,512	; LENGTH OF CODE
	JMP	WLP	; WRITE IT OUT AND RETURN
;
; --- EXIT PREP MODE ---
;
EXPREP:	MVI	A,0		; SET RESET COMMAND
	CALL	WAITO		; SEND IT TO CONTROLLER
	JMP	WERR		; GET RETURN CODE AND RETURN
;
; --- READ REV B STATUS STRING ---
;
BSTAT:	CALL	GTDRV		; GET DRIVE #
BSTAT1:	MVI	A,NSTAT		; GET STATUS COMMAND
	STA	RWCOM		; SET R/W COMMAND
	CALL	WAITO
	LDA	DRIVE
	CALL	WAITO
;
	LXI	H,128		; SET LENGTH
	SHLD	SLEN
	LXI	H,STATBF	; SET BUFFER ADDRESS
	SHLD	RADD
	CALL	RWSC1		; USE R/W ROUTINE TO GET DATA
	RC			; RETURN IF ERROR
;				; --- 2.5
	MVI	A,7
	STA	NSPR		; SET DEFAULT MAX # OF SPARE TRKS
	LXI	H,STATBF+35	; POINT TO #CYL/DRIVE
	CALL	GTDE		; GET COPY INTO (D,E)
	LXI	H,-306		; SET NUMBER EXPECTED FOR REV H DRIVE
	DAD	D		; ARE THEY THE SAME?
	MOV	A,L
	ORA	H
	JNZ	BSTAT2		; NO SO CONTINUE
	MVI	A,31		; YES, SO SET MAX # FOR REV H DRIVES
	STA	NSPR
;				; ----------
BSTAT2:	LXI	H,STATBF+33	; POINT TO #SECTORS/TRACK
	XRA	A
	CMP	M		; IS VALUE 0 (BUG IN EARLY ROM)?
	STC
	CMC			; INSURE CARRY IS CLEAR
	RNZ			; NO, SO RETURN
	MVI	M,20		; YES, SO FIX IT
	RET
;
;
;$I CDIAGNOS.IO		; SYSTEM DEPENDENT ROUTINES
;FILEID: CDIAGNOS.IO

;
RDPT:	IN	DATA		; READ DATA
	PUSH	PSW		; SAVE IT
	CALL	LSTT		; READ AND LIST STATUS
	LXI	D,MSG15
	CALL	PTMSG
	POP	PSW		; GET READ DATA BACK
	CALL	HEXOT		; SHOW IN HEX
	LXI	D,MSG16
RDP1:	CALL	PTMSG
	JMP	MST1		; BACK FOR NEXT OPERATION
;
RDST:	CALL	LSTT		; SHOW STATUS
	LXI	D,CRLF
	JMP	RDP1
;
ODPT:	CALL	INHEX		; INPUT HEX DATA
	JC	MST1		; IF INVALID, TRY AGAIN
	MOV	A,H		; GET HIGH BYTE
	ORA	A
	JNZ	MST1		; IF TOO BIG, TRY AGAIN
	MOV	A,L		; GET DATA BYTE
	OUT	DATA		; SEND IT TO CONTROLLER
	JMP	RDST		; NOW TEST STATUS
;
LSTT:	LXI	D,MSG14
	CALL	PTMSG		; START OF STATUS MESSAGE
	IN	STAT		; READ STATUS
	PUSH	PSW		; SAVE IT
	LXI	D,MSGT2		; MESSAGE FOR "BUSY"
	ANI	DRDY		; TEST READY BIT
	CPI	DRDYST		; IS IT READY
	JNZ	LSTT1		; IF NOT READY
	LXI	D,MSGT1		; MESSAGE FOR "READY"
LSTT1:	CALL	PTMSG
	POP	PSW		; GET STATUS WORD BACK
	LXI	D,MSGT3		; MESSAGE FOR "HOST TO DRIVE"
	ANI	DIFAC		; TEST BUSS DIRECTION BIT
	CPI	HTD		; IF HOST TO DRIVE
	JZ	LSTT2		; THE JUMP
	LXI	D,MSGT4		; MESSAGE FOR "DRIVE TO HOST"
LSTT2:	JMP	PTMSG		; LIST AND RETURN
;
;
;
TURNKT:	CALL	KTST	; DO KEYBOARD STATUS TEST
	IN	STAT	; LOOK AT BUSS DIRECTION
	ANI	DRDY OR DIFAC	; TEST BUS DIRECTION
	CPI	DRDYST OR DTH	; IS STATUS = READY & DRIVE-TO-HOST
	JNZ	TURNKT	; LOOP UNTIL 'DRIVE TO HOST'
	MVI	B,6	; SET DELAY COUNTER
	CALL	DELAY	; GOOD AT 4MHZ ALSO
	RET		;
;
;
;$I CRV.IO		; CORVUS BASIC IO ROUTINES
;FILEID: CRV.IO
;

TURN:				; WAIT FOR DRIVE-TO-HOST STATUS AND
	IN	STAT		; DELAY TILL DATA STABLE
	ANI	DRDY OR DIFAC	; TEST STATUS
	CPI	DRDYST OR DTH	; IS DRIVE READY & DRIVE-TO-HOST
	JNZ	TURN		; IF NOT THEN LOOP
	MVI	B, 25		; SET DELAY COUNT (FOR 6MHZ)
	CALL	DELAY
	IN	STAT		; CHECK DATA STILL STABLE
	ANI	DRDY OR DIFAC	; TEST STATUS
	CPI	DRDYST OR DTH	; IS DRIVE READY & DRIVE-TO-HOST
	JNZ	TURN		; IF NOT THEN START AGAIN
	MVI	B, 25		; SET DELAY COUNT (FOR 6MHZ)
	CALL	DELAY
	RET			;
;
DELAY:	DCR	B
	JNZ	DELAY
	RET
;
WAITI:	IN	STAT	; READ STATUS PORT
	ANI	DRDY OR DIFAC	; LOOK AT STATUS
	CPI	DRDYST OR DTH	; IS DRIVE READY & DRIVE-TO-HOST
	JNZ	WAITI	; LOOP UNTIL READY
	IN	DATA	; READ BYTE FROM DISC
	RET
;
WAITO:	PUSH	PSW	; SAVE COMMAND
WAITO1:	EI		; ENABLE INTERRUPTS
	NOP		; SHORT DELAY TO ALLOW FOR INTERRUPT
	NOP
	DI		; TURN INTERRUPTS OFF FOR TEST
	IN	STAT	; READ STATUS PORT
	ANI	DRDY OR DIFAC	; LOOK AT STATUS
	CPI	DRDYST OR HTD	; IS DRIVE READY & HOST-TO-DRIVE
	JNZ	WAITO1	; LOOP UNTIL READY
	POP	PSW
	OUT	DATA	; WRITE BYTE TO DISC
	EI		; ENABLE INTERRUPTS AGAIN
	RET
;
;
;$I GTBLK.IO		; GET BLOCK OF UNDETERMINED LENGTH ROUTINE
;FILEID: GTBLK.IO
;
; --- GET A BLOCK OF UNDETERMINED LENGTH BACK FROM DISC ---
;
GTBLK:
	LXI	D,0	; INIT COUNT
GTB1:	IN	STAT	; GET STATUS
	MOV	C,A	; SAVE IT
	ANI	DRDY	; TEST READY BIT
	CPI	DRDYST	; IS DRIVE READY
	JNZ	GTB1	; LOOP UNTIL READY
	MOV	A,C
	ANI	DIFAC	; TEST BUSS DIRECTION
	CPI	HTD	; IS IT HOST-TO-DRIVE
	JZ	GTB2	; IF  SO THEN NO MORE BYTES
	CALL	WAITI	; GET DATA BYTE
	MOV	M,A	; SAVE IT
	INX	H
	INX	D
	JMP	GTB1
GTB2:	XCHG		; GET COUNT IN (H,L)
	XTHL            ; SAVE IT
	PCHL            ; RETURN

;
;
;$I CRVINIT.IO		; RESYNC CONTROLLER ROUTINE
;FILEID: CRVINIT.IO
;
;
; --- INITIALIZE CONTROLLER ----
;
INIT:	MVI	A,0FFH	; GET AN INVALID COMMAND
	OUT	DATA	; SEND IT TO CONTROLLER
	MVI	B,150	; SET FOR LONG DELAY
	CALL	DELAY
	IN	STAT
	ANI	DRDY OR DIFAC	; LOOK AT DRIVE ACTIVE BIT
	CPI	DRDYST OR DTH	; IS STATUS = READY & DRIVE-TO-HOST
	JNZ	INIT	; LOOP UNTIL DRIVE-TO-HOST
	CALL	WAITI	; GET ERROR CODE
	CPI	8FH	; CHECK RETURN CODE
	JNZ	INIT	; IF NOT RIGHT, TRY AGAIN
	RET
;
;	---- MESSAGES ----
;
SMSG:	DB CR,LF,' --- CORVUS DISC DIAGNOSTIC ---'
	DB CR,LF,'  VERSION 2.6  /   FOR SOFTBOX',CR,LF,'$'
;
;$I CDIAGNOS.DAT	; DATA DECLARATIONS
;
MSG2:	DB CR,LF
	DB CR,LF,'        --- TEST MENU ---',CR,LF
	DB CR,LF,' 0.  LIST THIS MENU'
	DB CR,LF,' 1.  LIST INSTRUCTIONS'
	DB CR,LF,' 2.  DISC FORMAT CHECK'
	DB CR,LF,' 3.  READ CONTROLLER CODE VERSION #'
	DB CR,LF,' 4.  HEAD SERVO TEST'
	DB CR,LF,' 5.  MANUAL CONTROLLER DIAGNOSTIC'
	DB CR,LF,' 6.  UPDATE CONTROLLER CODE'
	DB CR,LF,' 7.  LIST/MODIFY DRIVE PARAMETERS'
	DB CR,LF,' 8.  LIST/MODIFY CONSTELLATION PARAMETERS'
	DB CR,LF,' 9.  EXIT BACK TO CP/M (CTL-C ALSO WORKS)'
	DB CR,LF,' P - "PARK" REV. H DRIVE HEADS FOR SHIPMENT',CR,LF,'$'
;
MSG3:	DB CR,LF,' TASK (0 TO LIST) : $'
;
;
MSG4:	DB CR,LF,' HIT   CONTROL-C  TO STOP TEST ',CR,LF,'$'
;
MSG5:	DB CR,LF,' TEST ABORTED',CR,LF,'$'
MSG6:	DB CR,LF,07
	DB ' --- THIS FEATURE IS NOT AVAILABLE UNDER VERS. 0 CONTROLLER CODE'
CRLF:	DB CR,LF,'$'
;
;
MSGE:	DB CR,LF,CR,LF,07,' ** DISC R/W ERROR # $'
;
MSGE1:	DB 'H **',CR,LF,'$'
;
DMSG:	DB CR,LF,' CORVUS DRIVE # (1-4) ? $'
;
;
CMSG:	DB '^C',CR,LF,'$'
;
MSG7:	DB CR,LF,07
	DB CR,LF,'    -BAD SECTORS RE-WRITTEN-',CR,LF
	DB CR,LF,' SURFACE  CYLINDER  SECTOR TRACK'
	DB CR,LF,'    #        #        #      #'
	DB CR,LF,' -------  --------  ------ -----'
	DB CR,LF,'$'
;
MSG7X:	DB CR,LF,' LIST DATA AGAIN (Y/N) ? $'
MSG8:	DB CR,LF,' NO BAD SECTORS FOUND !!',CR,LF,'$'
;
MSG9:	DB CR,LF,07,' OVER 63 BAD SECTORS FOUND AND RE-WRITTEN ',CR,LF,'$'
;
MSG10:	DB CR,LF,' DISC FORMAT CHECK IN PROGRESS ... ',CR,LF,'$'
;
MSG11:	DB CR,LF,' CONTROLLER CODE VERSION # =$'
;
MSGV:	DB '     REVISION # $'
;
MSGRV:	DB CR,LF
	DB CR,LF,' CONTROLLER ROM VERSION # $'
;
MSGDZ:	DB CR,LF
	DB ' DISK SIZE ( IN 512 BYTE BLOCKS ) : $'
;
MSG12:	DB CR,LF,' -------------- WARNING --------------'
	DB 07
	DB CR,LF,' THIS TEST CAN CAUSE LOSS OF USER DATA'
	DB CR,LF,'         (IF USED IMPROPERLY)',CR,LF
	DB CR,LF,' -------------------------------------'
	DB CR,LF,' THE COMMAND FORMAT IS:'
	DB CR,LF,'   R - READ A BYTE FROM THE CONTROLLER'
	DB CR,LF,' WXX - WRITE HEX BYTE TO CONTROLLER'
	DB CR,LF,'   S - READ CONTROLLER STATUS'
	DB CR,LF,'   E - EXIT TEST',CR,LF,'$'
;
MSG13:	DB CR,LF,' OPERATION (R,W,S,E-EXIT) : $'
;
MSG14:	DB CR,LF,' STATUS : $'
;
MSG15:	DB '      DATA = $'
;
MSG16:	DB 'H',CR,LF,'$'
;
;
MSG17:	DB CR,LF,07,' ** DIAGNOSTIC CODE NOT VALID **',CR,LF,'$'
;
MSGT1:	DB '    READY,  $'
;
MSGT2:	DB 'NOT READY,  $'
;
MSGT3:	DB 'HOST TO DRIVE $'
;
MSGT4:	DB 'DRIVE TO HOST $'
;
;
MSGI:	DB CR,LF
	DB CR,LF,' TO CONSERVE SPACE, THE INSTRUCTIONS HAVE'
	DB CR,LF,' BEEN REMOVED AND PLACED IN A SEPARATE'
	DB CR,LF,' FILE: CDIAGNOS.DOC.  TO READ THEM JUST'
	DB CR,LF,' TYPE THE FILE.'
	DB CR,LF,CR,LF,'$'
;
CRMSG:	DB CR,LF
	DB CR,LF,' PRESS RETURN TO CONTINUE$'
;
BIGMSG:	DB CR,LF,07,' ** WARNING **',CR,LF
	DB '    RESIDENT CP/M SYSTEM IS TOO SMALL TO READ ',CR,LF
	DB '    ALL OF CONTR. CODE INTO MEMORY.  IF CONTR. CODE',CR,LF
	DB '    BEING READ FROM THE CORVUS DRIVE THEN DO NOT',CR,LF
	DB '    CONTINUE.',CR,LF,'CONTINUE ? (Y/N):','$'
;
UMSG:	DB CR,LF
	DB ' CONTROLLER CODE FILE NAME ( CORVXX.CLR) :$'
;
UMSG2:	DB CR,LF,CR,LF,' WRITE CONTROLLER CODE TO DISC (Y/N) ? $'
;
JMSG:	DB CR,LF,' IS FORMAT SWITCH ON (OR FORMAT JUMPER INSTALLED) (Y/N) ? $'
;
FMSG:	DB CR,LF,07,' DO YOU REALLY WANT TO FORMAT THE DISC FIRST'
	DB CR,LF,' ( AND ERASE ALL THE DATA ON IT) (Y/N) ? $'
;
TMSG:	DB CR,LF,' -- THIS WILL TAKE ABOUT 1 MINUTE --',CR,LF,'$'
;
UMSG3:	DB CR,LF,CR,LF
	DB ' ---------- CONTROLLER CODE FILE HEADER MESSAGE -----------'
	DB CR,LF,CR,LF,'$'
;
UMSG4:	DB CR,LF,CR,LF
	DB ' ----------------------------------------------------------'
UMSGE:	DB CR,LF,'$'
;
UMSGL:	DB CR,LF,' CODE LENGTH = $'
;
UMSG5:	DB ' (512 BYTE BLOCKS)',CR,LF
	DB CR,LF,'$'
;
TMSGW:	DB 'BLOCK WRITTEN = '
;
UMSG6:	DB CR,LF,CR,LF,07,' ** INVALID CONTROLLER CODE FORMAT **',CR,LF,'$'
;
UMSG7:	DB CR,LF,CR,LF,07,' ** INVALID FILE NAME SPECIFIED **',CR,LF,CR,LF
	DB ' THE PROPER NAME FORMAT IS: NAME.CLR',CR,LF,CR,LF
	DB ' WHERE   NAME.CLR   IS THE FILE NAME FOR THE CONTROLLER CODE'
	DB CR,LF,CR,LF,'$'
;
UMSG8:	DB CR,LF,CR,LF,' THE CONTROLLER CODE HAS BEEN WRITTEN.  NOW TURN'
	DB CR,LF,' OFF THE FORMAT SWITCH (OR REMOVE THE JUMPER)'
	DB CR,LF,' AND RESET THE DRIVE BY EITHER FLIPPING THE'
	DB CR,LF,' DRIVE RESET SWITCH OR BY POWERING IT DOWN.'
	DB CR,LF,'$'
;
UMSG9:	DB CR,LF,CR,LF,07,' ** CONTROLLER CODE FILE NOT FOUND **',CR,LF,'$'
;
MSGE2:	DB CR,LF,CR,LF,07,' ** DISC READ ERROR **',CR,LF,'$'
;
;
MPMSGI:	DB CR,LF,07
	DB	 ' ------------- WARNING -------------'
	DB CR,LF,' CHANGING ANY OF FOLLOWING PARAMETERS'
	DB CR,LF,' CAN MAKE ANY USER DATA STORED ON THE'
	DB CR,LF,'            DISC UNUSABLE'
	DB CR,LF,' -----------------------------------'
	DB CR,LF,CR,LF
	DB CR,LF,' DO YOU WISH TO CONTINUE (Y/N) ? $'
;
MPMSG1:	DB CR,LF
	DB CR,LF,' ------ DRIVE PARAM MENU ------',CR,LF
	DB CR,LF,' S: CHANGE SPARED TRACK TABLE'
	DB CR,LF,' I: CHANGE SECTOR INTERLEAVING'
	DB CR,LF,' V: CHANGE VIRTUAL DRIVE OFFSETS'
	DB CR,LF,' E: EXIT BACK TO MAIN MENU',CR,LF
;
	DB CR,LF,' TASK ? $'
;
MPMSG2:	DB CR,LF,' WRITE CHANGES BACK TO DISC (Y/N) ? $'
;
REVAMSG: DB CR,LF,07,' ** FUNCTION NOT AVAILABLE YET ON REV A'
	DB ' DRIVES **',CR,LF,'$'
;
SPRMSG1: DB CR,LF
	 DB CR,LF,' ADD, REMOVE, OR EXIT (A,R,E) ? $'
;
ADMSG1:	DB CR,LF,07,' ** NO ROOM LEFT IN TABLE **',CR,LF,'$'
;
ADMSG2:	DB CR,LF,' NEW TRACK # TO SPARE ? $'
;
RM1MSG:	DB CR,LF,' TRACK # TO REMOVE ? $'
;
RM2MSG: DB CR,LF,CR,LF,07,' ** ENTRY NOT FOUND **',CR,LF,'$'
;
INTMSG1: DB CR,LF,' NEW SECTOR INTERLEAVING SPEC.'
	 DB CR,LF,' ( USE 12 FOR 5MBYTE DRIVE)'
	 DB CR,LF,' ( OR   9 FOR 10 OR 20 MBYTE DRIVES) : $'
;
DINMSG:	DB CR,LF,' SECTOR INTERLEAVING SPEC. = $'
VD1MSG:	DB CR,LF,' ALL CP/M BASED SYSTEMS CAN ADDRESS'
	DB CR,LF,' THE DRIVE AS ONE UNIT.  THUS THE'
	DB CR,LF,' VDO TABLE SHOULD BE SET WITH AN'
	DB CR,LF,' OFFSET OF 0 FOR VIRTUAL DRIVE 1'
	DB CR,LF,' AND  "-"  FOR THE REST (UNLESS APPLES'
	DB CR,LF,' ARE ALSO PRESENT).',CR,LF,'$'
;
VD2MSG:	DB CR,LF,' VIRTUAL DRIVE $'
;
VD3MSG:	DB ' : $'
;
DSPMSG:	DB CR,LF
	DB CR,LF,' --- SPARED TRACK TABLE ---',CR,LF,'$'
;
DSP1MSG: DB CR,LF,' > NO TRACKS ARE SPARED <',CR,LF,'$'
;
DV1MSG:	DB CR,LF,' --- VIRTUAL DRIVE TRACK ---'
	DB CR,LF,'        OFFSET TABLE',CR,LF
;
	DB CR,LF,'        DRIVE  TRACK'
	DB CR,LF,'        -----  -----'
	DB CR,LF,'$'
;
;
CNMSG1:	DB	CR,LF
	DB	CR,LF,' --- CONSTELLATION PARAM. MENU ---',CR,LF
	DB	CR,LF,' M: LIST/EDIT MUX TABLE'
	DB	CR,LF,' P: LIST/EDIT POLLING PARAMETERS'
	DB	CR,LF,' E: EXIT',CR,LF
	DB	CR,LF,' TASK ? $'
;
MX0MSG:	DB	CR,LF
	DB	CR,LF,' DO YOU WANT CHANGE THIS (Y/N) ?$'
;
MX1MSG:	DB	CR,LF
	DB	CR,LF,'              5      4'
	DB	CR,LF,'              6      3'
	DB	CR,LF,'              7      2'
	DB	CR,LF,'              8      1'
	DB	CR,LF,'                 =='
	DB	CR,LF
	DB	CR,LF,' IN THE FOLLOWING, SPECIFY WHAT IS'
	DB	CR,LF,' CONNECTED TO EACH SLOT IN THE MASTER'
	DB	CR,LF,' MUX.  THE SLOTS ARE NUMBERED AS IN THE'
	DB	CR,LF,' PICTURE ABOVE.  LEGAL RESPONSES ARE:'
	DB	CR,LF,' <RET> - NO CHANGE       - - NOTHING'
	DB	CR,LF,'     M - MUX             C - COMPUTER'
	DB	CR,LF,'     L - LSI-11'
	DB	CR,LF,CR,LF,'$'
;
MX2MSG:	DB	CR,LF,' SLOT $'
;
MX3MSG:	DB	' (-,M,C,L) : $'
;
DX1MSG:	DB	CR,LF
	DB	CR,LF,'  --- MASTER MUX CONFIGURATION ---'
	DB	CR,LF,CR,LF,'$'
;
DX2MSG:	DB	'                 ==',CR,LF,'$'
;
P1MSG:	DB	CR,LF,' DO YOU WISH TO CHANGE THE POLLING'
	DB	CR,LF,' PARAMETERS (NOT RECOMMENDED) (Y/N) ?$'
;
P2MSG:	DB	CR,LF,' PARAM. # $'
;
P3MSG:	DB	' : $'
;
P4MSG:	DB	CR,LF
	DB	CR,LF,' --- POLLING PARAMETERS ---',CR,LF
	DB	'$'
;
PKMSG:	DB	CR,LF,' ** THIS DRIVE DOES NOT REQUIRE PARKING OF HEADS'
	DB	' **',CR,LF,'$'
;
PKKMSG:	DB	CR,LF,' --- THE HEADS ARE NOW PARKED AND THE DRIVE IS'
	DB	' DISABLED ---',CR,LF,'$'
;
; ---- BUFFERS AND DATA ----
;
;
TYP:	DB	'CLR'	; CP/M FILE TYPE USED FOR CONTROLLER CODE
INI:	DB	'INI'	; FILE TYPE FOR UPDATE USING DEFAULTS (TRICK)
FMT:	DB	'FMT'	; FILE TYPE FOR FORMAT COMMAND (A TRICK)
TEST:	DB	CR,LF,' CORVUS REV B'; EXPECTED START OF HEADER
;
; --- FAKE COPY OF DATA FOR REV A STATUS STRING ---
;
REVADTA: DB	18	; # SECTORS/TRACK
	DB	3	; # HEADS
	DW	350	; # OF CYLINDERS
	DW	18936	; # OF 512 BYTE SECTORS
	DB	0
;
SBUF:	DS	2	; OLD STACK POINTER
TOP:	DS	2	; BUFFER FOR TOP OF RAM POINTER
RWCOM:	DS	1	; READ/WRITE COMMAND
DRIVE:	DS	1	; DRIVE # AND UPPER ADDRESS NIBBLE
DADD:	DS	2	; LOWER 16 BITS OF DISC ADDRESS
RADD:	DS	2	; POINTER TO RAM R/W LOCATION
SLEN:	DS	2	; SECTOR LENGTH FOR R/W OPERATION
DRIVEU:	DS	1	; BUFFER FOR DRIVE # USED IN SERVO TEST
DADDU:	DS	2	; BUFFER FOR DISC ADD. "  "   "     "
CTR:	DS	1	; ERROR COUNTER
SRTN:	DS	1	; BUFFER FOR RESULT OF VCHK ROUTINE
RTNCD:	DS	1	; BUFFER FOR SAVING ERROR RETURN CODE
RTLEN:	DS	2	; BUFFER FOR LENGTH OF RET. DATA BY GTBLK
NSEC:	DS	1	; BUFFER FOR # SEC TO READ/WRITE
BFPTR:	DS	2	; BUFFER POINTER
DECBUF:	DS	2	; BUFFER FOR DECIMAL OUT ROUTINE
MSGPTR:	DS	2	; POINTER TO MESSAGE FOR  KTST ROUTINE
MPTR	DS	2	; POINTER FOR RWTEST TO USE AS TEXT SOURCE
CDEND:	DS	2	; BUFFER FOR POINTER TO END OF CODE RAM IMAGE
CDLEN:	DS	1	; BUFFER FOR CODE LENGTH (IN 512 BYTE BLOCKS)
CODE:	DS	2	; BUFFER FOR SAVING POINTER
MNUPTR:	DS	2	; BUFFER FOR MENU SCANNER
CBLK:	DS	1	; BUFFER USED TO SAVE R/W COMMAND
CFLG:	DS	1	; FLAG USED TO INDICATE TABLE CHANGE
WFLG:	DB	0	; CCP OVERLAY FLAG
SKFG:	DS	1	; FLAG FOR SKIPPING BLOCKS OF REV B CODE
CTFG:	DS	1	; FLAG FOR SAVING CONTROLLER CODE TYPE (A OR B)
FMFG:	DS	1	; FLAG FOR FORMAT AND UPDATE
CKS:	DS	1	; BUFFER FOR CHECKSUM ROUTINE
EOFLG:	DB	0FFH	; END OF FILE FLAG - INIT TO FALSE
NSPR:	DB	7	; MAX # OF SPARE TRKS
;
PKBUF:	DB	00,00,0C3H,0C3H,0,0,0	; REV H PARK CMD HEADER
;
TXBUF:	DB	20	; SET BUFFER LENGTH
	DS	23	; ROOM FOR DATA
;
STATBF:	DS	130	; BUFFER FOR SAVING STATUS STRING
;
;$I CDIAGNOS.DB		; INCLUDE THE PREP BLOCK
; --- CONTROLLER "PREP" CODE BLOCK FROM 18.3 ---
;
CHKSUM	EQU	245		; IN DECIMAL
;
DCODE:	DB 0,0,62,3,211,106,211,107,175,50,17,96,33,0
	DB 0,34,18,96,205,116,0,62,3,211,126,205,175,129
	DB 183,40,30,254,1,40,41,254,50,40,66,254,51,40
	DB 84,254,7,40,116,62,143,50,17,96,33,0,0,34
	DB 18,96,195,160,129,205,167,0,33,0,0,34,18,96
	DB 205,116,0,195,0,0,1,0,2,205,233,129,17,0
	DB 130,237,176,33,0,0,34,254,129,205,61,0,33,0
	DB 0,34,18,96,195,160,129,205,175,129,50,253,129,33
	DB 0,0,34,254,129,215,33,0,118,34,18,96,195,160
	DB 129,1,1,2,205,233,129,126,50,253,129,33,0,0
	DB 34,254,129,231,194,160,129,33,1,0,34,254,129,231
	DB 33,0,0,34,18,96,195,160,129,33,1,162,34,18
	DB 96,175,50,0,162,50,253,129,33,0,0,34,254,129
	DB 205,221,128,205,13,129,40,248,33,0,164,237,75,0
	DB 162,6,0,3,183,237,66,235,213,33,0,162,237,176
	DB 225,17,0,20,25,34,18,96,195,160,129,205,11,0
	DB 205,169,129,192,58,253,129,230,224,205,59,129,58,253
	DB 129,230,224,198,1,205,59,129,58,253,129,230,224,198
	DB 2,205,59,129,58,253,129,230,224,198,3,205,59,129
	DB 195,169,129,58,9,96,15,15,15,71,58,253,129,230
	DB 224,198,32,50,253,129,184,56,23,175,50,253,129,42
	DB 254,129,35,34,254,129,235,42,2,96,183,237,82,48
	DB 3,246,255,201,195,164,0,33,202,96,71,62,20,203
	DB 63,203,63,119,120,50,253,129,247,205,19,0,48,67
	DB 215,42,18,96,58,253,129,203,7,203,7,203,7,230
	DB 7,119,35,237,75,254,129,113,35,112,35,58,253,129
	DB 230,31,119,35,34,18,96,58,0,162,198,4,50,0
	DB 162,48,7,62,16,50,21,96,24,28,33,0,98,17
	DB 0,130,1,0,2,237,176,223,205,167,0,58,253,129
	DB 198,4,33,202,96,53,194,71,129,201,49,237,97,205
	DB 116,0,195,21,128,58,20,96,254,255,201,243,62,195
	DB 50,12,72,33,213,129,34,13,72,219,116,205,119,0
	DB 62,79,211,107,219,105,62,68,211,107,62,131,211,107
	DB 62,237,211,104,251,24,254,62,205,211,104,62,1,211
	DB 127,62,3,211,107,211,106,219,105,225,251,237,77,62
	DB 213,211,104,195,125,0,0,0,0,0,0,0,0,0
	DB 248,1,0,0,2,0,1,1
;
	DS	80	; STACK SPACE
STACK	EQU	$
;
	ORG	(STACK+105H) AND 0FF00H	; START ON PAGE BOUNDARY
;
BUFF	EQU	$	; BUFFER FOR DISC READ/WRITE
;
;
	END
